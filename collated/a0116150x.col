//@author: a0116150x



	/**
	 * origin: ./src\speed\parser\Command.java
	 */

package speed.parser;

import java.util.ArrayList;
import java.util.Calendar;

public class Command {
	public enum COMMAND_TYPE {
		DEFAULT, ADD, EDIT, DELETE, LIST, SEARCH, COMPLETE, UNDO, REDO, EXIT, TEST
	}

	private COMMAND_TYPE commandType;
	private String taskID;
	private String taskName;
	private Calendar taskStartDate;
	private Calendar taskEndDate;
	private Calendar searchStartDate;
	private Calendar searchEndDate;
	private ArrayList<String> searchType;
	private ArrayList<String> searchKeywords;
	private String[] searchTags;
	private String[] taskIDsToDelete;
	private String[] taskIDsToComplete;
	private String[] taskTagsToAdd;
	private String[] taskTagsToRemove;
	private int recurPattern = -1;
	private int recurPeriod;

	public void setCommandType(COMMAND_TYPE parsedCommandType) {
		commandType = parsedCommandType;
	}

	public COMMAND_TYPE getCommandType() {
		if (commandType == COMMAND_TYPE.DEFAULT) {
			return COMMAND_TYPE.ADD;
		} else {
			return commandType;
		}
	}

	public void setTaskID(String ID) {
		taskID = ID;
	}

	public String getTaskID() {
		return taskID;
	}

	public void setTaskName(String name) {
		taskName = name;
	}

	public String getTaskName() {
		return taskName;
	}

	public void setTaskStartDate(Calendar startDate) {
		taskStartDate = startDate;
	}

	public Calendar getTaskStartDate() {
		return taskStartDate;
	}

	public void setTaskEndDate(Calendar endDate) {
		taskEndDate = endDate;
	}

	public Calendar getTaskEndDate() {
		return taskEndDate;
	}

	public void setTaskIDsToDelete(String[] IDs) {
		taskIDsToDelete = IDs;
	}

	public String[] getTaskIDsToDelete() {
		return taskIDsToDelete;
	}

	public void setTaskIDsToComplete(String[] IDs) {
		taskIDsToComplete = IDs;
	}

	public String[] getTaskIDsToComplete() {
		return taskIDsToComplete;
	}

	public Calendar getSearchStartDate() {
		return searchStartDate;
	}

	public void setSearchStartDate(Calendar searchStartDate) {
		this.searchStartDate = searchStartDate;
	}

	public Calendar getSearchEndDate() {
		return searchEndDate;
	}

	public void setSearchEndDate(Calendar searchEndDate) {
		this.searchEndDate = searchEndDate;
	}

	public ArrayList<String> getSearchType() {
		return searchType;
	}

	public void setSearchType(ArrayList<String> type) {
		searchType = type;
	}

	public ArrayList<String> getSearchKeywords() {
		return searchKeywords;
	}

	public void setSearchKeywords(ArrayList<String> keywords) {
		searchKeywords = keywords;
	}

	public String[] getSearchTags() {
		return searchTags;
	}

	public void setSearchTags(String[] tags) {
		searchTags = tags;
	}

	public String[] getTaskTagsToAdd() {
		return taskTagsToAdd;
	}

	public void setTaskTagsToAdd(String[] tags) {
		taskTagsToAdd = tags;
	}

	public String[] getTaskTagsToRemove() {
		return taskTagsToRemove;
	}

	public void setTaskTagsToRemove(String[] tags) {
		taskTagsToRemove = tags;
	}

	public void setRecurPattern(int pattern) {
		recurPattern = pattern;
	}

	public int getRecurPattern() {
		return recurPattern;
	}

	public void setRecurPeriod(int period) {
		recurPeriod = period;
	}

	public int getRecurPeriod() {
		return recurPeriod;
	}
}
	// End of segment: ./src\speed\parser\Command.java





	/**
	 * origin: ./src\speed\parser\DateParser.java
	 */

package speed.parser;
import java.util.Calendar;
import java.util.GregorianCalendar;

public class DateParser extends DateTimeRegexHandler {

	private final String CURRENT_CENTURY = "20";
	private final TimeParser timeParser = new TimeParser();

	private String currentDate;
	private boolean isStartDate = false;

	protected Calendar parse(String datetime) {
		currentDate = datetime;
		return parseDate(datetime);
	}

	protected Calendar parse(String datetime, boolean isStartDate, int default_hour, int default_min, int default_second) {
		currentDate = datetime;
		this.isStartDate = isStartDate;
		Calendar dateCal = parseDate(datetime);
		return timeParser.parse(currentDate, dateCal, default_hour, default_min, default_second);
	}

	private Calendar parseDate(String date) {
		Calendar cal = matchNaturalLanguage(date);
		cal = cal == null ? matchDayMonthYear(date) : cal;
		cal = cal == null ? matchDayMonth(date) : cal;
		cal = cal == null ? matchMonthDayYear(date) : cal;
		cal = cal == null ? matchMonthDay(date) : cal;
		return cal;
	}

	private Calendar matchDayMonthYear(String date) {
		String[] parsedDate = null;
		if (dateMatches(date, DD_MM_YYYY)) {
			parsedDate = dateMatch(date, DD_MM_YYYY);
		} else if (dateMatches(date, DD_MMM_YYYY)) {
			parsedDate = dateMatch(date, DD_MMM_YYYY);
			parsedDate[2] = toNumeral(parsedDate[2]);
		} else if (dateMatches(date, DDMMYYYY)) {
			parsedDate = dateMatch(date, DDMMYYYY);
		} else if (dateMatches(date, DD_MM_YY)) {
			parsedDate = dateMatch(date, DD_MM_YY);
			parsedDate[3] = CURRENT_CENTURY + parsedDate[3];
		} else if (dateMatches(date, DD_MMM_YY)) {
			parsedDate = dateMatch(date, DD_MMM_YY);
			parsedDate[2] = toNumeral(parsedDate[2]);
			parsedDate[3] = CURRENT_CENTURY + parsedDate[3];
		} else if (dateMatches(date, DDMMYY)) {
			parsedDate = dateMatch(date, DDMMYY);
			parsedDate[3] = CURRENT_CENTURY + parsedDate[3];
		}
		if (parsedDate == null) {
			return null;
		} else {
			currentDate = currentDate.replaceFirst(parsedDate[0], "");
			int year = Integer.parseInt(parsedDate[3]);
			int month = Integer.parseInt(parsedDate[2]) - 1;
			int day = Integer.parseInt(parsedDate[1]);
			return new GregorianCalendar(year, month, day);
		}
	}

	private Calendar matchDayMonth(String date) {
		String[] parsedDate = null;
		if (dateMatches(date, DD_MM)) {
			parsedDate = dateMatch(date, DD_MM);
		} else if (dateMatches(date, DD_MMM)) {
			parsedDate = dateMatch(date, DD_MMM);
			parsedDate[2] = toNumeral(parsedDate[2]);
		}
		if (parsedDate == null) {
			return null;
		} else {
			currentDate = currentDate.replaceFirst(parsedDate[0], "");
			Calendar now = Calendar.getInstance();
			int day = Integer.parseInt(parsedDate[1]);
			int month = Integer.parseInt(parsedDate[2]) - 1;
			int year = now.get(Calendar.YEAR);
			if (now.get(Calendar.MONTH) > month) {
				year += 1;
			} else if (now.get(Calendar.MONTH) == month && now.get(Calendar.DAY_OF_MONTH) > day) {
				year += 1;
			}
			return new GregorianCalendar(year, month, day);
		}
	}

	private Calendar matchMonthDayYear(String date) {
		String[] parsedDate = null;
		if (dateMatches(date, MM_DD_YYYY)) {
			parsedDate = dateMatch(date, MM_DD_YYYY);
		} else if (dateMatches(date, MMM_DD_YYYY)) {
			parsedDate = dateMatch(date, MMM_DD_YYYY);
			parsedDate[1] = toNumeral(parsedDate[1]);
		} else if (dateMatches(date, MMDDYYYY)) {
			parsedDate = dateMatch(date, MMDDYYYY);
		} else if (dateMatches(date, MM_DD_YY)) {
			parsedDate = dateMatch(date, MM_DD_YY);
			parsedDate[3] = CURRENT_CENTURY + parsedDate[3];
		} else if (dateMatches(date, MMM_DD_YY)) {
			parsedDate = dateMatch(date, MMM_DD_YY);
			parsedDate[3] = CURRENT_CENTURY + parsedDate[3];
			parsedDate[1] = toNumeral(parsedDate[1]);
		} else if (dateMatches(date, MMDDYY)) {
			parsedDate = dateMatch(date, MMDDYY);
			parsedDate[3] = CURRENT_CENTURY + parsedDate[3];
		}
		if (parsedDate == null) {
			return null;
		} else {
			currentDate = currentDate.replaceFirst(parsedDate[0], "");
			int year = Integer.parseInt(parsedDate[3]);
			int month = Integer.parseInt(parsedDate[1]) - 1;
			int day = Integer.parseInt(parsedDate[2]);
			return new GregorianCalendar(year, month, day);
		}
	}

	private Calendar matchMonthDay(String date) {
		String[] parsedDate = null;
		if (dateMatches(date, MM_DD)) {
			parsedDate = dateMatch(date, MM_DD);
		} else if (dateMatches(date, MMM_DD)) {
			parsedDate = dateMatch(date, MMM_DD);
			parsedDate[1] = toNumeral(parsedDate[1]);
		}
		if (parsedDate == null) {
			return null;
		} else {
			currentDate = currentDate.replaceFirst(parsedDate[0], "");
			Calendar now = Calendar.getInstance();
			int day = Integer.parseInt(parsedDate[2]);
			int month = Integer.parseInt(parsedDate[1]) - 1;
			int year = now.get(Calendar.YEAR);
			if (now.get(Calendar.MONTH) > month) {
				year += 1;
			} else if (now.get(Calendar.MONTH) == month && now.get(Calendar.DAY_OF_MONTH) > day) {
				year += 1;
			}
			return new GregorianCalendar(year, month, day);
		}
	}

	private Calendar matchNaturalLanguage(String date) {
		Calendar now = Calendar.getInstance();
		int thisYear = now.get(Calendar.YEAR);
		int thisMonth = now.get(Calendar.MONTH);
		int thisDayOfMonth = now.get(Calendar.DAY_OF_MONTH);
		if (dateMatches(date, PERIOD_AFTER_DATE)) {
			return matchPeriodAfterDate(date);
		} else if (dateMatches(date, DATE_PERIOD_LATER_EARLIER)) {
			return matchDatePeriodLaterEarlier(date);
		} else if (dateMatches(date, AFTER_BEFORE_DATE_PERIOD)) {
			return matchAfterBeforeDatePeriod(date);
		} else if (dateMatches(date, NOW)) {
			return new GregorianCalendar(thisYear, thisMonth, thisDayOfMonth);
		} else if (dateMatches(date, TODAY)) {
			currentDate = currentDate.replaceFirst(dateMatch(date, TODAY)[0], "");
			return new GregorianCalendar(thisYear, thisMonth, thisDayOfMonth);
		} else if (dateMatches(date, YESTERDAY)) {
			currentDate = currentDate.replaceFirst(dateMatch(date, YESTERDAY)[0], "");
			return new GregorianCalendar(thisYear, thisMonth, thisDayOfMonth - 1);
		} else if (dateMatches(date, TOMORROW)) {
			currentDate = currentDate.replaceFirst(dateMatch(date, TOMORROW)[0], "");
			return new GregorianCalendar(thisYear, thisMonth, thisDayOfMonth + 1);
		} else if (dateMatches(date, WHICH_DAY)) {
			return matchWhichDay(date);
		} else if (dateMatches(date, WHICH_PERIOD)) {
			return matchWhichPeriod(date);
		} else {
			return null;
		}
	}

	private Calendar matchPeriodAfterDate(String date) {
		String[] parsedDate = dateMatch(date, PERIOD_AFTER_DATE);
		Calendar cal = parseDate(parsedDate[4]);
		boolean add = parsedDate[3] == null || dateMatches(parsedDate[3], FROM+"|"+AFTER);
		boolean isEndOfPeriod = false;
		int periodLength;
		if (dateMatches(parsedDate[1], "a")) {
			periodLength = 1;
		} else if (dateMatches(parsedDate[1], "the")) {
			periodLength = 1;
			isEndOfPeriod = true;
		} else {
			periodLength = Integer.parseInt(parsedDate[1].trim());
		}
		periodLength = add ? periodLength : 0 - periodLength;
		String period = parsedDate[2];
		parseDatePeriodAndSetDate(cal, isEndOfPeriod, periodLength, period);
		return cal;
	}

	private Calendar matchAfterBeforeDatePeriod(String date) {
		String[] parsedDate = dateMatch(date, AFTER_BEFORE_DATE_PERIOD);
		Calendar now = Calendar.getInstance();
		int periodLength;
		String period;
		if (parsedDate[1] == null) {
			periodLength = Integer.parseInt(parsedDate[4].trim());
			period = parsedDate[5];
		} else {
			boolean add = dateMatches(parsedDate[1], AFTER);
			periodLength = Integer.parseInt(parsedDate[2].trim());
			periodLength = add ? periodLength : 0 - periodLength;
			period = parsedDate[3];
		}
		parseDatePeriodAndSetDate(now, false, periodLength, period);
		currentDate = currentDate.replaceFirst(parsedDate[0], "");
		return now;
	}

	private Calendar matchDatePeriodLaterEarlier(String date) {
		String[] parsedDate = dateMatch(date, DATE_PERIOD_LATER_EARLIER);
		Calendar now = Calendar.getInstance();
		boolean add = parsedDate[3] == null || dateMatches(parsedDate[3], LATER);
		int periodLength = Integer.parseInt(parsedDate[1].trim());
		periodLength = add ? periodLength : 0 - periodLength;
		String period = parsedDate[2];
		parseDatePeriodAndSetDate(now, false, periodLength, period);
		currentDate = currentDate.replaceFirst(parsedDate[0], "");
		return now;
	}

	private Calendar matchWhichPeriod(String date) {
		String[] parsedDate = dateMatch(date, WHICH_PERIOD);
		Calendar cal = Calendar.getInstance();
		String whichPeriod = parsedDate[1];
		String period = parsedDate[2];
		int addition = 0;
		if (dateMatches(whichPeriod, NEXT)) {
			addition = 1;
		} else if (dateMatches(whichPeriod, PREVIOUS)) {
			addition = -1;
		}
		parseDatePeriodAndSetDate(cal, !isStartDate, addition, period);
		return cal;
	}

	private void parseDatePeriodAndSetDate(Calendar cal, boolean isEndOfPeriod, int periodLength, String period) {
		if (dateMatches(period, DAY)) {
			cal.add(Calendar.DAY_OF_YEAR, periodLength);
		} else if (dateMatches(period, WEEK)) {
			cal.add(Calendar.WEEK_OF_YEAR, periodLength);
			setStartOrEndOfPeriod(isEndOfPeriod, cal, Calendar.DAY_OF_WEEK);
		} else if (dateMatches(period, MONTH)) {
			cal.add(Calendar.MONTH, periodLength);
			setStartOrEndOfPeriod(isEndOfPeriod, cal, Calendar.DAY_OF_MONTH);
		} else if (dateMatches(period, YEAR)) {
			cal.add(Calendar.YEAR, periodLength);
			setStartOrEndOfPeriod(isEndOfPeriod, cal, Calendar.DAY_OF_YEAR);
		}
	}

	private void setStartOrEndOfPeriod(boolean isEndOfPeriod, Calendar cal, int period) {
		if (isEndOfPeriod) {
			setEndOfPeriod(cal, period);
		} else if (isStartDate) {
			setStartOfPeriod(cal, period);
		}
	}

	protected void setStartOfPeriod(Calendar cal, int period) {
		cal.set(period, cal.getActualMinimum(period));
	}

	protected void setEndOfPeriod(Calendar cal, int period) {
		cal.set(period, cal.getActualMaximum(period));
	}

	private Calendar matchWhichDay(String date) {
		String[] parsedDate = dateMatch(date, WHICH_DAY);
		Calendar now = Calendar.getInstance();
		String whichDay = parsedDate[1];
		int day = checkDay(parsedDate[2]);
		if (whichDay == null) {
			if (now.get(Calendar.DAY_OF_WEEK) > day) {
				now.add(Calendar.WEEK_OF_YEAR, 1);
			}
		} else if (dateMatches(whichDay, NEXT)) {
			now.add(Calendar.WEEK_OF_YEAR, 1);
		} else if (dateMatches(whichDay, PREVIOUS)) {
			now.add(Calendar.WEEK_OF_YEAR, -1);
		}
		now.set(Calendar.DAY_OF_WEEK, day);
		currentDate = currentDate.replaceFirst(parsedDate[0], "");
		return now;
	}

	private int checkDay(String day) {
		int calendarDay = -1;
		if (dateMatches(day, MON)) {
			calendarDay = Calendar.MONDAY;
		} else if (dateMatches(day, TUE)) {
			calendarDay = Calendar.TUESDAY;
		} else if (dateMatches(day, WED)) {
			calendarDay = Calendar.WEDNESDAY;
		} else if (dateMatches(day, THU)) {
			calendarDay = Calendar.THURSDAY;
		} else if (dateMatches(day, FRI)) {
			calendarDay = Calendar.FRIDAY;
		} else if (dateMatches(day, SAT)) {
			calendarDay = Calendar.SATURDAY;
		} else if (dateMatches(day, SUN)) {
			calendarDay = Calendar.SUNDAY;
		}
		return calendarDay;
	}

	private String toNumeral(String month) {
		String numeral = "";
		if (dateMatches(month, JAN)) {
			numeral = "1";
		} else if (dateMatches(month, FEB)) {
			numeral = "2";
		} else if (dateMatches(month, MAR)) {
			numeral = "3";
		} else if (dateMatches(month, APR)) {
			numeral = "4";
		} else if (dateMatches(month, MAY)) {
			numeral = "5";
		} else if (dateMatches(month, JUN)) {
			numeral = "6";
		} else if (dateMatches(month, JUL)) {
			numeral = "7";
		} else if (dateMatches(month, AUG)) {
			numeral = "8";
		} else if (dateMatches(month, SEP)) {
			numeral = "9";
		} else if (dateMatches(month, OCT)) {
			numeral = "10";
		} else if (dateMatches(month, NOV)) {
			numeral = "11";
		} else if (dateMatches(month, DEC)) {
			numeral = "12";
		}
		return numeral;
	}
}

	// End of segment: ./src\speed\parser\DateParser.java





	/**
	 * origin: ./src\speed\parser\DateTimeParser.java
	 */

package speed.parser;

import java.util.Calendar;

public class DateTimeParser extends DateTimeRegexHandler{

	/**
	 * Regex for parsing datetime in command
	 */
	private final String DATE_TIME_TO_TIME = "(?:(?:from\\s+)?"+
		DATE_FORMATS+"(?:,?\\s+)("+TIME_RANGE_12+"|"+TIME_RANGE_24+")"+"|"+
		"("+TIME_RANGE_12+"|"+TIME_RANGE_24+")(?:,?\\s+)"+DATE_FORMATS+"|"+
		"("+TIME_RANGE_12+"|"+TIME_RANGE_24+"))";
	private final String FROM_DATETIME = "(?:from\\s+)?("+DATETIME_FORMATS+")";
	private final String TO_DATETIME = "to\\s+("+DATETIME_FORMATS+")";
	private final String FROM_TO = FROM_DATETIME + "\\s+" + TO_DATETIME;
	private final String DUE = "(?:due(?:\\s+(?:on|in))?|by|in|on)\\s+(?:the\\s+)?("+DATETIME_FORMATS+")";
	private final String DUE_WHICH_PERIOD = "(?:due(?:\\s+(?:on|in))?|by|in|on)\\s+(?:the\\s+)?(\\d+\\s+(?:"+DATE_PERIOD+"|"+TIME_PERIOD+"))";
	private final String RECUR = "(?:recurs?\\s+)?(?:every)(?:\\s*)?(\\d\\s)?("+DAY+"|"+WEEK+"|"+MONTH+"|"+YEAR+"|"+DAY_NAMES+")";
	private final String SIMPLE_RECUR = "(?:recurs?\\s)?("+DAILY+"|"+WEEKLY+"|"+MONTHLY+"|"+YEARLY+")";
	private final String RECUR_DAY = "(?:recurs?\\s+)?(?:every\\s*?)"+DAY_NAMES+"\\s+((?:"+TIME_RANGE_12+"|"+TIME_RANGE_24+")|(?:"+TIME_12+"|"+TIME_24+"))";

	private final boolean isStartDate = true;
	private final boolean isEndDate = false;

	private final DateParser dateParser = new DateParser();
	private String input;
	private String output;

	protected String parseCommand(String command, Command.COMMAND_TYPE type, Command commandObj) {
		output = command;
		// Do not evaluate strings within quotation marks
		input = command.replaceAll("\"[^\"]+\"", "");
		if (dateMatches(input, DATE_TIME_TO_TIME)) {
			matchDateTimeToTime(type, commandObj);
		} else if (dateMatches(input, FROM_TO)) {
			matchFromDateTimeToDateTime(type, commandObj);
		} else if (dateMatches(input, DUE)) {
			matchDueDateTime(commandObj);
		} else if (dateMatches(input, DUE_WHICH_PERIOD)) {
			matchDueWhichPeriod(commandObj);
		} else if (dateMatches(input, DATETIME_FORMATS)) {
			matchAnyDateTime(type, commandObj);
		} else {
			matchOnlyRecurrances(type, commandObj);
		}
		return output;
	}

	private void matchDateTimeToTime(Command.COMMAND_TYPE type, Command commandObj) {
		String match = dateMatch(input, DATE_TIME_TO_TIME)[0];
		Calendar startDate = dateParser.parse(match);
		// defaults to today if there is no start date
		startDate = startDate == null ? Calendar.getInstance() : startDate;
		Calendar endDate = (Calendar) startDate.clone();
		parseDateTimeToTime(match, startDate, endDate);
		setCommandObjStartAndEndDate(type, commandObj, startDate, endDate);
		if (dateMatches(input, RECUR_DAY)) {
			String[] recurMatch = dateMatch(input, RECUR_DAY);
			// Removes time range from output
			output = output.replaceFirst(recurMatch[2], "");
		}
		parseRecur(commandObj);
		output = output.replaceFirst(match, "");
	}

	private void matchFromDateTimeToDateTime(Command.COMMAND_TYPE type, Command commandObj) {
		String match = dateMatch(input, FROM_TO)[0];
		String[] fromDate = dateMatch(match, FROM_DATETIME);
		Calendar startDate = dateParser.parse(fromDate[1], isStartDate, 0, 0, 0);
		String[] toDate = dateMatch(match, TO_DATETIME);
		Calendar endDate = dateParser.parse(toDate[1], isEndDate, 23, 59, 59);
		if (startDate != null && endDate != null) {
			setCommandObjStartAndEndDate(type, commandObj, startDate, endDate);
			output = output.replaceFirst(match, "");
			parseRecur(commandObj);
		}
	}

	private void matchDueDateTime(Command commandObj) {
		String[] dates = dateMatch(input, DUE);
		// parses first instance of any datetime format found
		Calendar dueDate = dateParser.parse(dates[1], isEndDate, 23, 59, 59);
		if (dueDate != null) {
			commandObj.setTaskEndDate(dueDate);
			output = output.replaceFirst(dates[0], "");
			parseRecur(commandObj);
		}
	}

	private void matchDueWhichPeriod(Command commandObj) {
		String[] dates = dateMatch(input, DUE_WHICH_PERIOD);
		dates[1] = dates[1] + " time";
		Calendar dueDate = dateParser.parse(dates[1], isEndDate, 23, 59, 59);
		if (dueDate != null) {
			commandObj.setTaskEndDate(dueDate);
			output = output.replaceFirst(dates[0], "");
			parseRecur(commandObj);
		}
	}

	private void matchAnyDateTime(Command.COMMAND_TYPE type, Command commandObj) {
		String[] dates = dateMatch(input, DATETIME_FORMATS);
		Calendar date = dateParser.parse(dates[0], isEndDate, 23, 59, 59);
		if (date != null) {
			setCommandObjEndDate(type, commandObj, date);
			if (dateMatches(input, RECUR_DAY)) {
				String[] recurMatch = dateMatch(input, RECUR_DAY);
				// Removes time range from output
				output = output.replaceFirst(recurMatch[2], "");
			}
			parseRecur(commandObj);
			output = output.replaceFirst(dates[0], "");
		}
	}

	private void matchOnlyRecurrances(Command.COMMAND_TYPE type, Command commandObj) {
		parseRecur(commandObj);
		if (hasRecurPattern(commandObj)) {
			Calendar startDate = startOfDay(Calendar.getInstance());
			Calendar endDate = endOfDay(Calendar.getInstance());
			setCommandObjStartAndEndDate(type, commandObj, startDate, endDate);
		}
	}

	private boolean hasRecurPattern(Command commandObj) {
		return commandObj.getRecurPattern() != -1;
	}

	private void setCommandObjEndDate(Command.COMMAND_TYPE type, Command commandObj, Calendar date) {
		switch (type) {
			case ADD:
			case EDIT:
			case DEFAULT:
				commandObj.setTaskEndDate(date);
				break;
			case LIST:
			case SEARCH:
				Calendar startDate = date;
				Calendar endDate = (Calendar) date.clone();
				setPeriodStartOrEndDate(startDate, isStartDate);
				setPeriodStartOrEndDate(endDate, isEndDate);
				commandObj.setSearchStartDate(startOfDay(startDate));
				commandObj.setSearchEndDate(endOfDay(endDate));
				break;
		}
	}

	private void setCommandObjStartAndEndDate(Command.COMMAND_TYPE type, Command commandObj, Calendar startDate, Calendar endDate) {
		switch (type) {
			case ADD:
			case EDIT:
			case DEFAULT:
				commandObj.setTaskStartDate(startDate);
				commandObj.setTaskEndDate(endDate);
				break;
			case LIST:
			case SEARCH:
				commandObj.setSearchStartDate(startDate);
				commandObj.setSearchEndDate(endDate);
				break;
		}
	}

	private void setPeriodStartOrEndDate(Calendar date, boolean isStartDate) {
		if (dateMatches(input, PERIOD_AFTER_DATE)) {
			// extract period from input
			String period = dateMatch(input, PERIOD_AFTER_DATE)[2];
			if (isStartDate) {
				setStartOfPeriod(date, period);
			} else {
				setEndOfPeriod(date, period);
			}
		} else if (dateMatches(input, WHICH_PERIOD)) {
			String period = input;
			if (isStartDate) {
				setStartOfPeriod(date, period);
			} else {
				setEndOfPeriod(date, period);
			}
		}
	}

	private void setStartOfPeriod(Calendar date, String period) {
		if (dateMatches(period, WEEK)) {
			dateParser.setStartOfPeriod(date, Calendar.DAY_OF_WEEK);
		} else if (dateMatches(period, MONTH)) {
			dateParser.setStartOfPeriod(date, Calendar.DAY_OF_MONTH);
		} else if (dateMatches(period, YEAR)) {
			dateParser.setStartOfPeriod(date, Calendar.DAY_OF_YEAR);
		}
	}

	private void setEndOfPeriod(Calendar date, String period) {
		if (dateMatches(period, WEEK)) {
			dateParser.setEndOfPeriod(date, Calendar.DAY_OF_WEEK);
		} else if (dateMatches(period, MONTH)) {
			dateParser.setEndOfPeriod(date, Calendar.DAY_OF_MONTH);
		} else if (dateMatches(period, YEAR)) {
			dateParser.setEndOfPeriod(date, Calendar.DAY_OF_YEAR);
		}
	}

	private void parseDateTimeToTime(String match, Calendar startDate, Calendar endDate) {
		if (dateMatches(match, TIME_RANGE_12)) {
			parseDateRangeTime12Format(match, startDate, endDate);
		} else if (dateMatches(match, TIME_RANGE_24)) {
			parseDateRangeTime24Format(match, startDate, endDate);
		}
	}

	private void parseDateRangeTime12Format(String match, Calendar startDate, Calendar endDate) {
		String[] parsedTime = dateMatch(match, TIME_RANGE_12);
		setStartOfDateRangeTime12Format(startDate, parsedTime);
		setEndOfDateRangeTime12Format(endDate, parsedTime);
		if (startDate.after(endDate)) {
			// Set end date to the next day if start time is after end time
			endDate.add(Calendar.DAY_OF_YEAR, 1);
		}
	}

	private void setStartOfDateRangeTime12Format(Calendar startDate, String[] parsedTime) {
		int startHour = Integer.parseInt(parsedTime[1]);
		int startMinute = parsedTime[2] == null ? 0 : Integer.parseInt(parsedTime[2]);
		int startSecond = parsedTime[3] == null ? 0 : Integer.parseInt(parsedTime[3]);
		if (parsedTime[4] == null) {
			// Sets am/pm of start time to that of end time
			parsedTime[4] = parsedTime[8];
		}
		if (parsedTime[4].equalsIgnoreCase(PM) && startHour < 12) {
			startHour += 12;
		} else if (parsedTime[4].equalsIgnoreCase(AM) && startHour == 12) {
			startHour -= 12;
		}
		setTimeOfDate(startDate, startHour, startMinute, startSecond);
	}

	private void setEndOfDateRangeTime12Format(Calendar endDate, String[] parsedTime) {
		int endHour = Integer.parseInt(parsedTime[5]);
		int endMinute = parsedTime[6] == null ? 0 : Integer.parseInt(parsedTime[6]);
		int endSecond = parsedTime[7] == null ? 0 : Integer.parseInt(parsedTime[7]);
		if (parsedTime[8].equalsIgnoreCase(PM) && endHour < 12) {
			endHour += 12;
		} else if (parsedTime[8].equalsIgnoreCase(AM) && endHour == 12) {
			endHour -= 12;
		}
		setTimeOfDate(endDate, endHour, endMinute, endSecond);
	}

	private void parseDateRangeTime24Format(String match, Calendar startDate, Calendar endDate) {
		String[] parsedTime = dateMatch(match, TIME_RANGE_24);
		setStartOfDateRangeTime24Format(startDate, parsedTime);
		setEndOfDateRangeTime24Format(endDate, parsedTime);
		if (startDate.after(endDate)) {
			// Set end date to the next day if start time is after end time
			endDate.add(Calendar.DAY_OF_YEAR, 1);
		}
	}

	private void setStartOfDateRangeTime24Format(Calendar startDate, String[] parsedTime) {
		if (isArmyTimeFormat(parsedTime[1])) {
			setDateRangeTime24Format(startDate, parsedTime[4], parsedTime[5], parsedTime[3]);
		} else {
			setDateRangeTime24Format(startDate, parsedTime[1], parsedTime[2], parsedTime[3]);
		}
	}

	private void setEndOfDateRangeTime24Format(Calendar endDate, String[] parsedTime) {
		if (isArmyTimeFormat(parsedTime[6])) {
			setDateRangeTime24Format(endDate, parsedTime[9], parsedTime[10], parsedTime[8]);
		} else {
			setDateRangeTime24Format(endDate, parsedTime[6], parsedTime[7], parsedTime[8]);
		}
	}

	private boolean isArmyTimeFormat(String firstMatchOfTime24Regex) {
		return firstMatchOfTime24Regex == null;
	}

	private void setDateRangeTime24Format(Calendar date, String hour, String minute, String second) {
		int endHour = Integer.parseInt(hour);
		int endMinute = Integer.parseInt(minute);
		int endSecond = second == null ? 0 : Integer.parseInt(second);
		setTimeOfDate(date, endHour, endMinute, endSecond);
	}

	private void parseRecur(Command commandObj) {
		int recurPeriod = 1;
		int recurPattern = -1;
		if (dateMatches(input, RECUR)) {
			String[] recur = dateMatch(input, RECUR);
			recurPattern = parseRecurPattern(recur[2]);
			if (recur[1] != null) {
				recurPeriod = Integer.parseInt(recur[1].trim());
			}
			output = output.replaceFirst(RECUR, "");
		} else if (dateMatches(input, SIMPLE_RECUR)) {
			String[] recur = dateMatch(input, SIMPLE_RECUR);
			recurPattern = parseRecurPattern(recur[1]);
			output = output.replaceFirst(SIMPLE_RECUR, "");
		}
		commandObj.setRecurPattern(recurPattern);
		commandObj.setRecurPeriod(recurPeriod);
	}

	private int parseRecurPattern(String pattern) {
		int recurPattern = -1;
		if (dateMatches(pattern, DAY) || dateMatches(pattern, DAILY)) {
			recurPattern = Calendar.DAY_OF_YEAR;
		} else if (dateMatches(pattern, WEEK) || dateMatches(pattern, WEEKLY) || dateMatches(pattern, DAY_NAMES)) {
			recurPattern = Calendar.WEEK_OF_YEAR;
		} else if (dateMatches(pattern, MONTH) || dateMatches(pattern, MONTHLY)) {
			recurPattern = Calendar.MONTH;
		} else if (dateMatches(pattern, YEAR) || dateMatches(pattern, YEARLY)) {
			recurPattern = Calendar.YEAR;
		}
		return recurPattern;
	}

	private void setTimeOfDate(Calendar date, int hour, int minute, int second) {
		date.set(Calendar.HOUR_OF_DAY, hour);
		date.set(Calendar.MINUTE, minute);
		date.set(Calendar.SECOND, second);
	}

	private Calendar startOfDay(Calendar cal) {
		setTimeOfDate(cal, 0, 0, 0);
		return cal;
	}

	private Calendar endOfDay(Calendar cal) {
		setTimeOfDate(cal, 23, 59, 59);
		return cal;
	}
}

	// End of segment: ./src\speed\parser\DateTimeParser.java





	/**
	 * origin: ./src\speed\parser\DateTimeRegexHandler.java
	 */

package speed.parser;

import static org.mentaregex.Regex.match;
import static org.mentaregex.Regex.matches;

public class DateTimeRegexHandler {

	/**
	 * Regex for month names
	 */
	protected final String JAN = "Jan(?:uary)?";
	protected final String FEB = "Feb(?:ruary)?";
	protected final String MAR = "Mar(?:ch)?";
	protected final String APR = "Apr(?:il)?";
	protected final String MAY = "May";
	protected final String JUN = "Jun(?:e)?";
	protected final String JUL = "Jul(?:y)?";
	protected final String AUG = "Aug(?:ust)?";
	protected final String SEP = "Sep(?:tember)?";
	protected final String OCT = "Oct(?:ober)?";
	protected final String NOV = "Nov(?:ember)?";
	protected final String DEC = "Dec(?:ember)?";

	/**
	 * Regex for datetime measurements
	 */
	protected final String SECOND = "seconds?";
	protected final String MINUTE = "minutes?";
	protected final String HOUR = "hours?";
	protected final String DAY = "days?";
	protected final String WEEK = "weeks?";
	protected final String MONTH = "months?";
	protected final String YEAR = "years?";
	protected final String DATE_PERIOD = "("+DAY+"|"+WEEK+"|"+MONTH+"|"+YEAR+")";
	protected final String TIME_PERIOD = "("+SECOND+"|"+MINUTE+"|"+HOUR+")";

	/**
	 * Regex for recurrence in natural language
	 */
	protected final String DAILY = "daily";
	protected final String WEEKLY = "weekly";
	protected final String MONTHLY = "monthly";
	protected final String YEARLY = "yearly|annually";

	/**
	 * Regex for days in week
	 */
	protected final String MON = "mon(?:day)?";
	protected final String TUE = "tues|tue(?:sday)?";
	protected final String WED = "wed(?:nesday)?";
	protected final String THU = "thurs?|thu(?:rsday)?";
	protected final String FRI = "fri(?:day)?";
	protected final String SAT = "sat(?:urday)?";
	protected final String SUN = "sun(?:day)?";
	protected final String DAY_NAMES = "("+MON+"|"+TUE+"|"+WED+"|"+THU+"|"+FRI+"|"+SAT+"|"+SUN+")";

	/**
	 * Regex for natural language such as
	 * after 3 hours
	 * before 1 month
	 * 3 years time
	 */
	protected final String AFTER = "after";
	protected final String BEFORE = "before";
	protected final String AFTER_BEFORE_DATE_PERIOD = "(?:(?:"+
		"("+AFTER+"|"+BEFORE+")\\s+)(\\d+)\\s+"+DATE_PERIOD+")|(?:"+
		"(\\d+)\\s+"+DATE_PERIOD+"(?:\\s+time))";
	protected final String AFTER_BEFORE_TIME_PERIOD = "(?:(?:"+
		"("+AFTER+"|"+BEFORE+")\\s+)(\\d+)\\s+"+TIME_PERIOD+")|(?:"+
		"(\\d+)\\s+"+TIME_PERIOD+"(?:\\s+time))";

	/**
	 * Regex for natural language such as
	 * 5 minutes later
	 * 3 years ago
	 */
	protected final String LATER = "later|"+AFTER;
	protected final String EARLIER = "earlier|ago|"+BEFORE;
	protected final String DATE_PERIOD_LATER_EARLIER = "(\\d+)\\s+"+DATE_PERIOD+"\\s+("+LATER+"|"+EARLIER+")";
	protected final String TIME_PERIOD_LATER_EARLIER = "(\\d+)\\s+"+TIME_PERIOD+"\\s+("+LATER+"|"+EARLIER+")";

	/**
	 * Regex for natural language such as
	 * this monday
	 * next wed
	 * last week
	 */
	protected final String THIS = "this";
	protected final String NEXT = "next";
	protected final String PREVIOUS = "previous|last";
	protected final String WHICH_DAY = "(?:("+THIS+"|"+NEXT+"|"+PREVIOUS+")\\s+)?"+DAY_NAMES;
	protected final String WHICH_PERIOD = "("+THIS+"|"+NEXT+"|"+PREVIOUS+")\\s+"+DATE_PERIOD;

	/**
	 * Regex for broken down datetime formats
	 */
	protected final String DATE_CONNECTOR = "[- /.]";
	protected final String ORDINALS = "(?:st|nd|rd|th)?";
	protected final String YY = "(\\d\\d)";
	protected final String YYYY = "((?:19|20)\\d\\d)";
	protected final String MM = "(0[1-9]|1[012])";
	protected final String M = "(0?[1-9]|1[012])";
	protected final String MMM = "("+JAN+"|"+FEB+"|"+MAR+"|"+APR+"|"+MAY+"|"+JUN+"|"+JUL+"|"+AUG+"|"+SEP+"|"+OCT+"|"+NOV+"|"+DEC+")";
	protected final String DD = "(0[1-9]|[12][0-9]|3[01])";
	protected final String D = "(0?[1-9]|[12][0-9]|3[01])";
	protected final String PM = "pm";
	protected final String AM = "am";
	protected final String TIME_12 = "(?:(0?[1-9]|1[012])(?:[:\\.]([0-5][0-9]))?(?::([0-5][0-9]))?)\\s*(am|pm)";
	protected final String TIME_24 = "(?:(2[0-3]|1[0-9]|0?[0-9])[:\\.]([0-5][0-9])(?::([0-5][0-9]|[0-9]))?|(2[0-3]|1[0-9]|0[0-9])([0-5][0-9]))";
	protected final String TIME_RANGE_12 = "(?:(0?[1-9]|1[012])(?:[:\\.]([0-5][0-9]))?(?::([0-5][0-9]))?)\\s*(am|pm)?(?:\\s+to\\s+|\\s*-\\s*)"+TIME_12;
	protected final String TIME_RANGE_24 = TIME_24+"(?:\\s+to\\s+|\\s*-\\s*)"+TIME_24;

	/**
	 * Regex for common date formats
	 */
	protected final String DD_MM_YYYY = D + DATE_CONNECTOR + M + DATE_CONNECTOR + YYYY;
	protected final String DD_MMM_YYYY = D + ORDINALS + DATE_CONNECTOR + MMM + DATE_CONNECTOR + YYYY;
	protected final String DDMMYYYY = DD + MM + YYYY;
	protected final String DD_MM_YY = D + DATE_CONNECTOR + M + DATE_CONNECTOR + YY;
	protected final String DD_MMM_YY = D + ORDINALS + DATE_CONNECTOR + MMM + DATE_CONNECTOR + YY;
	protected final String DDMMYY = DD + MM + YY;

	protected final String MM_DD_YYYY = M + DATE_CONNECTOR + D + DATE_CONNECTOR + YYYY;
	protected final String MMM_DD_YYYY = MMM + DATE_CONNECTOR + D + ORDINALS + DATE_CONNECTOR + YYYY;
	protected final String MMDDYYYY = MM + DD + YYYY;
	protected final String MM_DD_YY = M + DATE_CONNECTOR + D + DATE_CONNECTOR + YY;
	protected final String MMM_DD_YY = MMM + DATE_CONNECTOR + D + ORDINALS + DATE_CONNECTOR + YY;
	protected final String MMDDYY =  MM + DD + YY;

	protected final String DD_MM = D + DATE_CONNECTOR + M;
	protected final String DD_MMM = D + ORDINALS + "(?:" + DATE_CONNECTOR + "|" + "\\s+of\\s+)" + MMM;

	protected final String MM_DD = M + DATE_CONNECTOR + D;
	protected final String MMM_DD =  MMM + DATE_CONNECTOR + D + ORDINALS;

	protected final String NOW = "now";
	protected final String TODAY = "today";
	protected final String TOMORROW = "tomorrow|tmr|tmrw|tml";
	protected final String YESTERDAY = "yesterday|yda|yta|ytd";

	/**
	 * Regex for combination of all common date formats
	 */
	protected final String SIMPLE_DATE_FORMATS = "(?:"+
		DD_MM_YYYY+"|"+
		DD_MMM_YYYY+"|"+
		DDMMYYYY+"|"+
		DD_MM_YY+"|"+
		DD_MMM_YY+"|"+
		DDMMYY+"|"+
		MM_DD_YYYY+"|"+
		MMM_DD_YYYY+"|"+
		MMDDYYYY+"|"+
		MM_DD_YY+"|"+
		MMM_DD_YY+"|"+
		MMDDYY+"|"+
		DD_MM+"|"+
		DD_MMM+"|"+
		MM_DD+"|"+
		MMM_DD+"|"+
		NOW+"|"+
		TODAY+"|"+
		TOMORROW+"|"+
		YESTERDAY+"|"+
		WHICH_DAY+"|"+
		WHICH_PERIOD+")";

	/**
	 * Regex for natural language such as
	 * the day after tmr
	 * a week from today
	 */
	protected final String FROM = "from";
	protected final String PERIOD_AFTER_DATE = "(the|a|\\d+)\\s+"+DATE_PERIOD+"\\s+("+FROM+"|"+AFTER+"|"+BEFORE+")\\s+("+SIMPLE_DATE_FORMATS+")";

	/**
	 * Regex for all date formats
	 */
	protected final String DATE_FORMATS = "(?:" +
		PERIOD_AFTER_DATE+"|"+
		DATE_PERIOD_LATER_EARLIER+"|"+
		AFTER_BEFORE_DATE_PERIOD+"|"+
		SIMPLE_DATE_FORMATS+")";

	/**
	 * Regex for all time formats
	 */
	protected final String TIME_FORMATS = "(?:"+
		TIME_12+"|"+
		TIME_24+"|"+
		TIME_PERIOD_LATER_EARLIER+"|"+
		AFTER_BEFORE_TIME_PERIOD+")";

	/**
	 * Regex for all datetime formats
	 */
	protected final String DATETIME_FORMATS = "(?:"+
		DATE_FORMATS+"(?:,?\\s+)"+TIME_FORMATS+"|"+
		TIME_FORMATS+"(?:,?\\s+)"+DATE_FORMATS+"|"+
		DATE_FORMATS+"|"+
		TIME_FORMATS+")";

	protected String[] dateMatch(String input, String regex) {
		return match(input, "/(\\b" + regex + "\\b)/ig");
	}

	protected boolean dateMatches(String input, String regex) {
		return matches(input, "/\\b" + regex + "\\b/ig");
	}
}

	// End of segment: ./src\speed\parser\DateTimeRegexHandler.java





	/**
	 * origin: ./src\speed\parser\Parser.java
	 */

package speed.parser;

import org.apache.commons.lang3.StringUtils;

import java.util.ArrayList;
import java.util.Arrays;

import static org.mentaregex.Regex.match;
import static org.mentaregex.Regex.matches;

public class Parser {

	private final DateTimeParser dateTimeParser = new DateTimeParser();

	private String command;
	private Command commandObj;
	private Command.COMMAND_TYPE commandType;
	private final int TYPO_DISTANCE = 1;

	private final String[] addCommands = {"add", "insert"};
	private final String[] editCommands = {"edit", "update", "change", "modify", "make"};
	private final String[] deleteCommands = {"delete", "remove", "destroy", "del", "rm"};
	private final String[] listCommands = {"list", "ls", "speed/view"};
	private final String[] searchCommands = {"search", "find"};
	private final String[] completeCommands = {"complete", "done", "finish", "fin"};
	private final String[] undoCommands = {"undo"};
	private final String[] redoCommands = {"redo"};
	private final String[] exitCommands = {"quit", "exit"};
	private final String[] testCommands = {"runtest", "systest"};

	private final String taskIDIdentifier = "[TROtro]";
	private final String completed = "completed?(?:\\s+tasks?)?";
	private final String floating = "floating(?:\\s+tasks?)?|reminders?";
	private final String overdue = "overdue(?:\\s+tasks?)?";

	public Command parseCommand(String userCommand) {
		command = userCommand;
		String commandTypeString = getFirstWord(command).trim().toLowerCase();
		commandType = parserCommandType(commandTypeString);
		return generateCommandObj();
	}

	private String getFirstWord(String input) {
		return input.split("\\s+")[0];
	}

	private Command.COMMAND_TYPE parserCommandType(String commandTypeString) {
		if (isAddCommand(commandTypeString)) {
			return Command.COMMAND_TYPE.ADD;
		} else if (isEditCommand(commandTypeString)) {
			return Command.COMMAND_TYPE.EDIT;
		} else if (isDeleteCommand(commandTypeString)) {
			return Command.COMMAND_TYPE.DELETE;
		} else if (isListCommand(commandTypeString)) {
			return Command.COMMAND_TYPE.LIST;
		} else if (isSearchCommand(commandTypeString)) {
			return Command.COMMAND_TYPE.SEARCH;
		} else if (isCompleteCommand(commandTypeString)) {
			return Command.COMMAND_TYPE.COMPLETE;
		} else if (isUndoCommand(commandTypeString)) {
			return Command.COMMAND_TYPE.UNDO;
		} else if (isRedoCommand(commandTypeString)) {
			return Command.COMMAND_TYPE.REDO;
		} else if (isExitCommand(commandTypeString)) {
			return Command.COMMAND_TYPE.EXIT;
		} else if (isTestCommand(commandTypeString)) {
			return Command.COMMAND_TYPE.TEST;
		} else {
			return Command.COMMAND_TYPE.DEFAULT;
		}
	}

	private boolean isAddCommand(String commandTypeString) {
		return containsCommand(commandTypeString, addCommands);
	}

	private boolean isEditCommand(String commandTypeString) {
		return containsCommand(commandTypeString, editCommands);
	}

	private boolean isDeleteCommand(String commandTypeString) {
		return containsCommand(commandTypeString, deleteCommands);
	}

	private boolean isListCommand(String commandTypeString) {
		return containsCommand(commandTypeString, listCommands);
	}

	private boolean isSearchCommand(String commandTypeString) {
		return containsCommand(commandTypeString, searchCommands);
	}

	private boolean isCompleteCommand(String commandTypeString) {
		return containsCommand(commandTypeString, completeCommands);
	}

	private boolean isUndoCommand(String commandTypeString) {
		return containsCommand(commandTypeString, undoCommands);
	}

	private boolean isRedoCommand(String commandTypeString) {
		return containsCommand(commandTypeString, redoCommands);
	}

	private boolean isExitCommand(String commandTypeString) {
		return containsCommand(commandTypeString, exitCommands);
	}

	private boolean isTestCommand(String commandTypeString) {
		return containsCommand(commandTypeString, testCommands);
	}

	private boolean containsCommand(String commandTypeString, String[] commands) {
		boolean result = false;
		for (String command : commands) {
			if (isFalsePositive("edit", "exit", command, commandTypeString)) {
				return false;
			} else if (isFalsePositive("fin", "find", command, commandTypeString)) {
				return false;
			} else if (StringUtils.getLevenshteinDistance(commandTypeString, command) <= TYPO_DISTANCE) {
				result = true;
			}
		}
		return result;
	}

	private boolean isFalsePositive(String correctA, String correctB, String checkA, String checkB) {
		if (checkA.equalsIgnoreCase(correctA) && checkB.equalsIgnoreCase(correctB)) {
			return true;
		} else if (checkA.equalsIgnoreCase(correctB) && checkB.equalsIgnoreCase(correctA)) {
			return true;
		} else {
			return false;
		}
	}

	private Command generateCommandObj() {
		commandObj = new Command();
		commandObj.setCommandType(commandType);
		String commandDetails = removeCommand();
		if (!commandDetails.equals("")) {
			switch (commandType) {
				case ADD:
				case DEFAULT:
					generateAddCommandObj(commandDetails);
					break;
				case EDIT:
					generateEditCommandObj(commandDetails);
					break;
				case DELETE:
					generateDeleteCommandObj(commandDetails);
					break;
				case LIST:
					generateListCommandObj(commandDetails);
					break;
				case SEARCH:
					generateSearchCommandObj(commandDetails);
					break;
				case COMPLETE:
					generateCompleteCommandObj(commandDetails);
					break;
			}
		}
		return commandObj;
	}

	private String removeCommand() {
		if (commandType == Command.COMMAND_TYPE.DEFAULT) {
			return command;
		} else if (matches(command, "\\s+")) {
			return command.replaceFirst("^(\\w+)\\s+", "");
		} else {
			return "";
		}
	}

	private void generateAddCommandObj(String commandDetails) {
		assert (!commandDetails.trim().equals("")) : "commandDetails is empty!";
		commandObj.setTaskTagsToAdd(parseTaskTagsAddition(commandDetails));
		commandDetails = removeTaskTagsAddition(commandDetails);
		commandDetails = dateTimeParser.parseCommand(commandDetails, commandType, commandObj);
		commandObj.setTaskName(parseTaskName(commandDetails));
	}

	private void generateEditCommandObj(String commandDetails) {
		assert (!commandDetails.trim().equals("")) : "commandDetails is empty!";
		String[] IDs = parseTaskID(commandDetails);
		if (IDs != null) {
		commandObj.setTaskID(IDs[0]);
		}
		commandDetails = removeTaskID(commandDetails);
		commandObj.setTaskTagsToRemove(parseTaskTagsRemoval(commandDetails));
		commandDetails = removeTaskTagsRemoval(commandDetails);
		commandObj.setTaskTagsToAdd(parseTaskTagsAddition(commandDetails));
		commandDetails = removeTaskTagsAddition(commandDetails);
		commandDetails = dateTimeParser.parseCommand(commandDetails, commandType, commandObj);
		commandObj.setTaskName(parseTaskName(commandDetails));
	}

	private void generateDeleteCommandObj(String commandDetails) {
		assert (!commandDetails.trim().equals("")) : "commandDetails is empty!";
		commandObj.setTaskIDsToDelete(parseMultipleTaskID(commandDetails));
	}

	private void generateListCommandObj(String commandDetails) {
		assert (!commandDetails.trim().equals("")) : "commandDetails is empty!";
		commandDetails = parseTaskTypesToList(commandDetails);
		dateTimeParser.parseCommand(commandDetails, commandType, commandObj);
	}

	private void generateSearchCommandObj(String commandDetails) {
		assert (!commandDetails.trim().equals("")) : "commandDetails is empty!";
		commandObj.setSearchTags(parseTaskTagsAddition(commandDetails));
		commandDetails = removeTaskTagsAddition(commandDetails);
		commandDetails = dateTimeParser.parseCommand(commandDetails, commandType, commandObj);
		String[] array = commandDetails.trim().split("\\s+");
		ArrayList<String> keywords = new ArrayList<String>();
		for (String keyword : array) {
			keywords.add(removeLeadingAndClosingPunctuation(keyword));
		}
		commandObj.setSearchKeywords(keywords);
	}

	private void generateCompleteCommandObj(String commandDetails) {
		assert (!commandDetails.trim().equals("")) : "commandDetails is empty!";
		commandObj.setTaskIDsToComplete(parseMultipleTaskID(commandDetails));
	}

	private String parseTaskName(String commandDetails) {
		return removeLeadingAndClosingPunctuation(commandDetails).replaceAll("\"", "");
	}

	private String[] parseTaskID(String commandDetails) {
		return match(commandDetails, "/("+taskIDIdentifier+"\\d+)/g");
	}

	private String[] parseMultipleTaskID(String commandDetails) {
		ArrayList<String> IDs = parseRangeIDs(commandDetails);
		commandDetails = commandDetails.replaceAll("("+taskIDIdentifier+"?(\\d+))[\\s+]?(?:-|to)[\\s+]?("+taskIDIdentifier+"?(\\d+))", "");
		String[] singleIDs = match(commandDetails, "/\\b("+taskIDIdentifier+"?\\d+)\\b/g");
		if (singleIDs != null) {
			IDs.addAll(Arrays.asList(singleIDs));
		}
		String[] allIDs = IDs.size() == 0 ? null : IDs.toArray(new String[IDs.size()]);
		return allIDs;
	}

	private String parseTaskTypesToList(String commandDetails) {
		ArrayList<String> type = new ArrayList<String>();
		if (matches(commandDetails, "/("+completed+")/ig")) {
			type.add("complete");
			commandDetails = commandDetails.replaceAll(completed, "");
		}
		if (matches(commandDetails, "/("+floating+")/ig")) {
			type.add("floating");
			commandDetails = commandDetails.replaceAll(floating, "");
		}
		if (matches(commandDetails, "/("+overdue+")/ig")) {
			type.add("overdue");
			commandDetails = commandDetails.replaceAll(overdue, "");
		}
		if (type.size() > 0) {
			commandObj.setSearchType(type);
		}
		return commandDetails;
	}

	private ArrayList<String> parseRangeIDs(String commandDetails) {
		ArrayList<String> IDs = new ArrayList<String>();
		String[] rangeIDs = match(commandDetails, "/("+taskIDIdentifier+"?(\\d+))[\\s+]?(?:-|to)[\\s+]?("+taskIDIdentifier+"?(\\d+))/g");
		if (rangeIDs != null) {
			for (int i = 0; i < rangeIDs.length; i += 4) {
				int start = Integer.parseInt(rangeIDs[i + 1]);
				int end = Integer.parseInt(rangeIDs[i + 3]);
				String startID = rangeIDs[i];
				String endID = rangeIDs[i + 2];
				if (start > end) {
					start = Integer.parseInt(rangeIDs[i + 3]);
					end = Integer.parseInt(rangeIDs[i + 1]);
					startID = rangeIDs[i + 2];
					endID = rangeIDs[i];
				}
				IDs.add(startID);
				for (Integer j = start + 1; j < end; j++) {
					IDs.add(j.toString());
				}
				IDs.add(endID);
			}
		}
		return IDs;
	}

	private String removeTaskID(String commandDetails) {
		return commandDetails.replaceFirst(""+taskIDIdentifier+"\\d+", "");
	}

	private String[] parseTaskTagsAddition(String commandDetails) {
		return match(commandDetails, "/(\\B@[a-zA-Z0-9-]+)/g");
	}

	private String[] parseTaskTagsRemoval(String commandDetails) {
		String[] removalMatches = match(commandDetails, "/((?:removes?|rm)\\s?(?:@[a-zA-Z0-9-]+\\s?)+)/g");
		ArrayList<String> tagMatches = new ArrayList<String>();
		if (removalMatches != null) {
			for (String match : removalMatches) {
				tagMatches.addAll(Arrays.asList(parseTaskTagsAddition(match)));
			}
			String[] tags = new String[tagMatches.size()];
			for (int i = 0; i < tagMatches.size(); i++) {
				tags[i] = tagMatches.get(i);
			}
			return tags;
		} else {
			return null;
		}
	}

	private String removeTaskTagsAddition(String commandDetails) {
		return commandDetails.replaceAll("\\B@[a-zA-Z0-9-]+", "");
	}

	private String removeTaskTagsRemoval(String commandDetails) {
		return commandDetails.replaceAll("(?:removes?|rm)\\s?(?:@[a-zA-Z0-9-]+\\s?)+", "");
	}

	private String removeLeadingAndClosingPunctuation(String input) {
		return input.replaceFirst("^[^0-9a-zA-Z]+", "").replaceAll("[^0-9a-zA-Z]+$", "");
	}
}
	// End of segment: ./src\speed\parser\Parser.java





	/**
	 * origin: ./src\speed\parser\ParserTest.java
	 */

package speed.parser;

import org.junit.Test;

import java.util.Calendar;

import static org.junit.Assert.assertArrayEquals;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNull;

public class ParserTest {

	Parser parser = new Parser();

	@Test
	public void testBasicAddCommand() throws Exception {
		String input = "add unit testing";
		Command addCommand = parser.parseCommand(input);
		assertEquals(Command.COMMAND_TYPE.ADD, addCommand.getCommandType());
		assertEquals("unit testing", addCommand.getTaskName());
	}

	@Test
	public void testAddCommandWithDate() throws Exception {
		String input = "add unit testing 10 Oct 2014";
		Command addCommand = parser.parseCommand(input);
		assertEquals(Command.COMMAND_TYPE.ADD, addCommand.getCommandType());
		assertEquals("unit testing", addCommand.getTaskName());
		Calendar actualCal = addCommand.getTaskEndDate();
		assertEquals(2014, actualCal.get(Calendar.YEAR));
		assertEquals(Calendar.OCTOBER, actualCal.get(Calendar.MONTH));
		assertEquals(10, actualCal.get(Calendar.DAY_OF_MONTH));
	}

	@Test
	public void testAddCommandWithDateAndTime12Hours() throws Exception {
		String input = "add unit testing 10 Oct 2014 10.45pm";
		Command addCommand = parser.parseCommand(input);
		assertEquals(Command.COMMAND_TYPE.ADD, addCommand.getCommandType());
		assertEquals("unit testing", addCommand.getTaskName());
		Calendar actualCal = addCommand.getTaskEndDate();
		assertEquals(2014, actualCal.get(Calendar.YEAR));
		assertEquals(Calendar.OCTOBER, actualCal.get(Calendar.MONTH));
		assertEquals(10, actualCal.get(Calendar.DAY_OF_MONTH));
		assertEquals(22, actualCal.get(Calendar.HOUR_OF_DAY));
		assertEquals(45, actualCal.get(Calendar.MINUTE));
	}

	@Test
	public void testAddCommandWithDateAndTime24Hours() throws Exception {
		String input = "add unit testing 10 Oct 2014 2245";
		Command addCommand = parser.parseCommand(input);
		assertEquals(Command.COMMAND_TYPE.ADD, addCommand.getCommandType());
		assertEquals("unit testing", addCommand.getTaskName());
		Calendar actualCal = addCommand.getTaskEndDate();
		assertEquals(2014, actualCal.get(Calendar.YEAR));
		assertEquals(Calendar.OCTOBER, actualCal.get(Calendar.MONTH));
		assertEquals(10, actualCal.get(Calendar.DAY_OF_MONTH));
		assertEquals(22, actualCal.get(Calendar.HOUR_OF_DAY));
		assertEquals(45, actualCal.get(Calendar.MINUTE));
	}

	@Test
	public void testEditCommandName() throws Exception {
		String input = "edit t1 unit testing";
		Command addCommand = parser.parseCommand(input);
		assertEquals(Command.COMMAND_TYPE.EDIT, addCommand.getCommandType());
		assertEquals("t1", addCommand.getTaskID());
		assertEquals("unit testing", addCommand.getTaskName());
	}

	@Test
	public void testEditCommandDate() throws Exception {
		String input = "edit t1 tomorrow";
		Command addCommand = parser.parseCommand(input);
		assertEquals(Command.COMMAND_TYPE.EDIT, addCommand.getCommandType());
		assertEquals("t1", addCommand.getTaskID());
		Calendar expectedCal = Calendar.getInstance();
		Calendar actualCal = addCommand.getTaskEndDate();
		assertEquals(expectedCal.get(Calendar.YEAR), actualCal.get(Calendar.YEAR));
		assertEquals(expectedCal.get(Calendar.MONTH), actualCal.get(Calendar.MONTH));
		assertEquals(expectedCal.get(Calendar.DAY_OF_MONTH)+1, actualCal.get(Calendar.DAY_OF_MONTH));
	}

	@Test
	public void testBasicDeleteCommand() throws Exception {
		String input = "delete t1";
		Command addCommand = parser.parseCommand(input);
		assertEquals(Command.COMMAND_TYPE.DELETE, addCommand.getCommandType());
		String[] expectedArray = {"t1"};
		assertArrayEquals(expectedArray, addCommand.getTaskIDsToDelete());
	}

	@Test
	public void testMultipleDeleteCommand() throws Exception {
		String input = "delete t1 o2 r3";
		Command addCommand = parser.parseCommand(input);
		assertEquals(Command.COMMAND_TYPE.DELETE, addCommand.getCommandType());
		String[] expectedArray = {"t1", "o2", "r3"};
		assertArrayEquals(expectedArray, addCommand.getTaskIDsToDelete());
	}

	@Test
	public void testInvalidIDDeleteCommand() throws Exception {
		String input = "delete z3";
		Command addCommand = parser.parseCommand(input);
		assertEquals(Command.COMMAND_TYPE.DELETE, addCommand.getCommandType());
		assertNull(addCommand.getTaskIDsToDelete());
	}

	@Test
	public void testListCommandSingleDate() throws Exception {
		String input = "list today";
		Command addCommand = parser.parseCommand(input);
		assertEquals(Command.COMMAND_TYPE.LIST, addCommand.getCommandType());
		Calendar expectedDate = Calendar.getInstance();
		Calendar actualStartDate = addCommand.getSearchStartDate();
		Calendar actualEndDate = addCommand.getSearchEndDate();
		assertEquals(expectedDate.get(Calendar.YEAR), actualStartDate.get(Calendar.YEAR));
		assertEquals(expectedDate.get(Calendar.MONTH), actualStartDate.get(Calendar.MONTH));
		assertEquals(expectedDate.get(Calendar.DAY_OF_MONTH), actualStartDate.get(Calendar.DAY_OF_MONTH));
		assertEquals(0, actualStartDate.get(Calendar.HOUR_OF_DAY));
		assertEquals(0, actualStartDate.get(Calendar.MINUTE));
		assertEquals(0, actualStartDate.get(Calendar.SECOND));
		assertEquals(expectedDate.get(Calendar.YEAR), actualEndDate.get(Calendar.YEAR));
		assertEquals(expectedDate.get(Calendar.MONTH), actualEndDate.get(Calendar.MONTH));
		assertEquals(expectedDate.get(Calendar.DAY_OF_MONTH), actualEndDate.get(Calendar.DAY_OF_MONTH));
		assertEquals(23, actualEndDate.get(Calendar.HOUR_OF_DAY));
		assertEquals(59, actualEndDate.get(Calendar.MINUTE));
		assertEquals(59, actualEndDate.get(Calendar.SECOND));
	}

	@Test
	public void testListCommandDateRange() throws Exception {
		String input = "list today to 2 days after";
		Command addCommand = parser.parseCommand(input);
		assertEquals(Command.COMMAND_TYPE.LIST, addCommand.getCommandType());
		Calendar expectedDate = Calendar.getInstance();
		Calendar actualStartDate = addCommand.getSearchStartDate();
		Calendar actualEndDate = addCommand.getSearchEndDate();
		assertEquals(expectedDate.get(Calendar.YEAR), actualStartDate.get(Calendar.YEAR));
		assertEquals(expectedDate.get(Calendar.MONTH), actualStartDate.get(Calendar.MONTH));
		assertEquals(expectedDate.get(Calendar.DAY_OF_MONTH), actualStartDate.get(Calendar.DAY_OF_MONTH));
		assertEquals(0, actualStartDate.get(Calendar.HOUR_OF_DAY));
		assertEquals(0, actualStartDate.get(Calendar.MINUTE));
		assertEquals(0, actualStartDate.get(Calendar.SECOND));
		assertEquals(expectedDate.get(Calendar.YEAR), actualEndDate.get(Calendar.YEAR));
		assertEquals(expectedDate.get(Calendar.MONTH), actualEndDate.get(Calendar.MONTH));
		assertEquals(expectedDate.get(Calendar.DAY_OF_MONTH)+2, actualEndDate.get(Calendar.DAY_OF_MONTH));
		assertEquals(23, actualEndDate.get(Calendar.HOUR_OF_DAY));
		assertEquals(59, actualEndDate.get(Calendar.MINUTE));
		assertEquals(59, actualEndDate.get(Calendar.SECOND));
	}

	@Test
	public void testBasicSearchCommand() throws Exception {
		String input = "search hello";
		Command addCommand = parser.parseCommand(input);
		assertEquals(Command.COMMAND_TYPE.SEARCH, addCommand.getCommandType());
		String[] expectedArray = {"hello"};
		assertArrayEquals(expectedArray, addCommand.getSearchKeywords().toArray());
	}

	@Test
	public void testMultipleSearchCommand() throws Exception {
		String input = "search hello world";
		Command addCommand = parser.parseCommand(input);
		assertEquals(Command.COMMAND_TYPE.SEARCH, addCommand.getCommandType());
		String[] expectedArray = {"hello", "world"};
		assertArrayEquals(expectedArray, addCommand.getSearchKeywords().toArray());
	}

	@Test
	public void testBasicCompleteCommand() throws Exception {
		String input = "complete t1";
		Command addCommand = parser.parseCommand(input);
		assertEquals(Command.COMMAND_TYPE.COMPLETE, addCommand.getCommandType());
		String[] expectedArray = {"t1"};
		assertArrayEquals(expectedArray, addCommand.getTaskIDsToComplete());
	}

	@Test
	public void testMultipleCompleteCommand() throws Exception {
		String input = "complete t1 o2 r3";
		Command addCommand = parser.parseCommand(input);
		assertEquals(Command.COMMAND_TYPE.COMPLETE, addCommand.getCommandType());
		String[] expectedArray = {"t1", "o2", "r3"};
		assertArrayEquals(expectedArray, addCommand.getTaskIDsToComplete());
	}

	@Test
	public void testUndoCommand() throws Exception {
		String input = "undo";
		Command addCommand = parser.parseCommand(input);
		assertEquals(Command.COMMAND_TYPE.UNDO, addCommand.getCommandType());
	}

	@Test
	public void testExitCommand() throws Exception {
		String input = "quit";
		Command addCommand = parser.parseCommand(input);
		assertEquals(Command.COMMAND_TYPE.EXIT, addCommand.getCommandType());
	}
}
	// End of segment: ./src\speed\parser\ParserTest.java





	/**
	 * origin: ./src\speed\parser\TimeParser.java
	 */

package speed.parser;

import java.util.Calendar;

public class TimeParser extends DateTimeRegexHandler {

	protected Calendar parse(String datetime, Calendar cal, int default_hour, int default_min, int default_second){
		Time time = parseTime(datetime);
		if (cal != null && time != null) {
			cal.set(Calendar.HOUR_OF_DAY, time.getHour());
			cal.set(Calendar.MINUTE, time.getMinute());
			cal.set(Calendar.SECOND, time.getSecond());
		} else if (cal != null) {
			cal.set(Calendar.HOUR_OF_DAY, default_hour);
			cal.set(Calendar.MINUTE, default_min);
			cal.set(Calendar.SECOND, default_second);
		} else if (time != null) {
			cal = Calendar.getInstance();
			cal.set(Calendar.HOUR_OF_DAY, time.getHour());
			cal.set(Calendar.MINUTE, time.getMinute());
			cal.set(Calendar.SECOND, time.getSecond());
		}
		return cal;
	}

	private Time parseTime(String time) {
		Time t = null;
		if (dateMatches(time, TIME_12)) {
			t = parseTime12Format(time);
		} else if (dateMatches(time, TIME_24)) {
			t = parseTime24Format(time);
		} else if (dateMatches(time, TIME_PERIOD_LATER_EARLIER)) {
			t = parseTimePeriodLaterEarlier(time);
		} else if (dateMatches(time, AFTER_BEFORE_TIME_PERIOD)) {
			t = parseAfterBeforeTimePeriod(time);
		} else if (dateMatches(time, NOW)) {
			t = new Time();
		}
		return t;
	}

	private Time parseTime12Format(String time) {
		String[] parsedTime = dateMatch(time, TIME_12);
		int hour = Integer.parseInt(parsedTime[1]);
		if (parsedTime[4].trim().equalsIgnoreCase(PM) && hour < 12) {
			hour += 12;
		} else if (parsedTime[4].trim().equalsIgnoreCase(AM) && hour == 12) {
			hour -= 12;
		}
		int minute = parsedTime[2] == null ? 0 : Integer.parseInt(parsedTime[2]);
		int second = parsedTime[3] == null ? 0 : Integer.parseInt(parsedTime[3]);
		return new Time(hour, minute, second);
	}

	private Time parseTime24Format(String time) {
		String[] parsedTime = dateMatch(time, TIME_24);
		int hour;
		int minute;
		if (parsedTime[1] == null) {
			hour = Integer.parseInt(parsedTime[4]);
			minute = Integer.parseInt(parsedTime[5]);
		} else {
			hour = Integer.parseInt(parsedTime[1]);
			minute = Integer.parseInt(parsedTime[2]);
		}
		int second = parsedTime[3] == null ? 59 : Integer.parseInt(parsedTime[3]);
		return new Time(hour, minute, second);
	}

	private Time parseTimePeriodLaterEarlier(String time) {
		String[] parsedTime = dateMatch(time, TIME_PERIOD_LATER_EARLIER);
		boolean add = parsedTime[3] == null || dateMatches(parsedTime[3], LATER);
		int periodLength = Integer.parseInt(parsedTime[1].trim());
		periodLength = add ? periodLength : 0 - periodLength;
		String period = parsedTime[2];
		return parseTimePeriodAndSetTime(period, periodLength);
	}

	private Time parseAfterBeforeTimePeriod(String time) {
		String[] parsedTime = dateMatch(time, AFTER_BEFORE_TIME_PERIOD);
		int periodLength;
		String period;
		if (parsedTime[1] == null) {
			periodLength = Integer.parseInt(parsedTime[4].trim());
			period = parsedTime[5];
		} else {
			boolean add = dateMatches(parsedTime[1], AFTER);
			periodLength = Integer.parseInt(parsedTime[2].trim());
			periodLength = add ? periodLength : 0 - periodLength;
			period = parsedTime[3];
		}
		return parseTimePeriodAndSetTime(period, periodLength);
	}

	private Time parseTimePeriodAndSetTime(String period, int periodLength) {
		Time t = new Time();
		if (dateMatches(period, SECOND)) {
			t.setSecond(t.getSecond() + periodLength);
		} else if (dateMatches(period, MINUTE)) {
			t.setMinute(t.getMinute() + periodLength);
		} else if (dateMatches(period, HOUR)) {
			t.setHour(t.getHour() + periodLength);
		}
		return t;
	}

	private class Time {
		private int hour;
		private int minute;
		private int second;

		public Time() {
			Calendar now = Calendar.getInstance();
			this.hour = now.get(Calendar.HOUR_OF_DAY);
			this.minute = now.get(Calendar.MINUTE);
			this.second = now.get(Calendar.SECOND);
		}

		public Time(int hour, int minute, int second) {
			this.hour = hour;
			this.minute = minute;
			this.second = second;
		}

		public void setHour(int hour) {
			this.hour = hour;
		}

		public int getHour() {
			return hour;
		}

		public void setMinute(int minute) {
			this.minute = minute;
		}

		public int getMinute() {
			return minute;
		}

		public void setSecond(int second) {
			this.second = second;
		}

		public int getSecond() {
			return second;
		}
	}
}

	// End of segment: ./src\speed\parser\TimeParser.java





