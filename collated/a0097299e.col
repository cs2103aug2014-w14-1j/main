//@author: a0097299e



	/**
	 * origin: ./src\speed\storage\Storage.java
	 */

package speed.storage;

import com.google.gson.Gson;

import speed.task.Task;
import speed.task.TaskComparator;

import java.io.*;
import java.util.*;
import java.util.logging.FileHandler;
import java.util.logging.Level;
import java.util.logging.Logger;

/*
 * This class acts as the storage for the task manager software. It keeps track of lists of tasks
 * the user adds, and allows the user to retrieve them. In addition, the Storage generates recurring
 * instances of repeating tasks.
 * 
 * There are 4 types of task lists: Floating, Overdue, Completed and Task. See the Task class for
 * more details. They are implemented as PriorityQueues.
 * 
 * The Storage contains an internal FileHandler class which handles all file operations.
 * 
 * The Storage requires JSON and GSON libraries.
 * 
 * Limitations (described in developer guide):
 * When modifying a Task object, it is important to delete it from the Storage first before editing it,
 * then insert it back. This is to ensure the Task is kept in the right list.
 * 
 * Exceptions thrown by the Storage: IOException
 * All exceptions are always thrown out. Whoever is using the Storage needs to know and handle it
 */

public class Storage {
	
	private static final int RECUR_YEAR_LIMIT = 3;				//the default limit for recurring tasks
	private static final int ID_COUNTER_INCREASE = 1;
	private static final String STORAGE_LOG = "storagelog.txt";
	
	private Logger storage_logger;
	private FileHandler log_writer;
	private TaskFileReader taskFileReader;
	private PriorityQueue<Task> list_task;
	private PriorityQueue<Task> list_floating;
	private PriorityQueue<Task> list_overdue;
	private PriorityQueue<Task> list_completed;
	private ArrayList<LinkedList<Task>> id_table;
	private int id_counter;
	
	//Constructor***************************************************************************

	public Storage(String task_fn, String float_fn, String o_fn, String c_fn) throws IOException {
		storage_logger = Logger.getLogger(Storage.class.getName());
		log_writer = new FileHandler(STORAGE_LOG);
		storage_logger.addHandler(log_writer);
		taskFileReader = new TaskFileReader(task_fn, float_fn, o_fn, c_fn);
		initFiles();
		maintainListIntegrity();
		updateRecurringTasks();
		checkForOverdueTasks();
	}

	//Insert methods************************************************************************
	
	/*
	 * Inserts a task into its appropriate list. If it is a recurring task, generate
	 * repeating copies of it.
	 * 
	 * Assumption: This task is unique and does not already exist inside the lists
	 * If it was an existing task, it should have been deleted beforehand
	 */
	
	public void insert(Task task) throws IOException {
		storage_logger.log(Level.FINE, "Insert operation");
		checkForOverdueTasks();
		if (task.hasNoId()) {								//for new tasks with no ID
			assignID(task);
		}
		
		insert(task, retrieveTaskList(task));
		
		if (task.isRecur()) {
			ArrayList<Task> task_recur_chain = generateRecurringTasks(task);
			for (Task recur_task : task_recur_chain) {
				insert(recur_task, retrieveTaskList(recur_task));
			}
		}
		
		save();
	}
	
	private void assignID(Task task) {
		storage_logger.log(Level.FINE, "New task, no ID, assigning ID");
		id_counter += ID_COUNTER_INCREASE;
		task.setId(id_counter);
	}

	private void insert(Task task, PriorityQueue<Task> list) {
		assert !task.hasNoId();
		list.add(task);
		if (task.getId() >= id_table.size()) {
			assert task.getId() == id_table.size() + 1;
			storage_logger.log(Level.FINE, "New task index" + task.getId() + "Creating new index in table");
			id_table.add(new LinkedList<Task>());
		}
		id_table.get(task.getId()).add(task);
	}
	
	/*
	 * Generates copies of a task and returns them in an ArrayList. The task is cloned, then
	 * the start and end dates are increased according to the recur pattern and period, until
	 * the last task's end date exceeds the date limit.
	 * 
	 * This method should not be called for a non-recurring task. This means the task must have
	 * non-null dates, appropriate recur pattern (Calendar field) and non-negative recur period
	 */
	private ArrayList<Task> generateRecurringTasks(Task task) {
		assert task.isRecur();
		storage_logger.log(Level.FINE, "Recurring task, generating recurring copies");
		
		ArrayList<Task> task_recur_chain = new ArrayList<Task>();
		
		Calendar limit = task.getRecurLimit();
		if (limit == null) {							//there is no limit: use default
			limit = getDefaultLimit();
		}
		
		//create new task instances. Increase their date
		while (task.getEndDate().before(limit)) {
			task = task.clone();
			
			Calendar start = task.getStartDate();
			start.add(task.getRecurPattern(), task.getRecurPeriod());
			Calendar end = task.getEndDate();
			end.add(task.getRecurPattern(), task.getRecurPeriod());
			
			if (end.after(limit)) {
				break;
			}
			
			task.setDates(start, end, task.getRecurPattern(), task.getRecurPeriod(), task.getRecurLimit());
			task_recur_chain.add(task);
		}
		storage_logger.log(Level.FINE, task_recur_chain.size() + " tasks generated");
		return task_recur_chain;
	}
	
	/*
	 * Get default limit, equal to time of insertion + RECUR_YEAR_LIMIT
	 */
	private Calendar getDefaultLimit() {
		Calendar limit = Calendar.getInstance();
		limit.add(Calendar.YEAR, RECUR_YEAR_LIMIT);
		return limit;
	}
	
	//Delete methods***************************************************
	
	/*
	 * Deletes a task and all tasks with the same ID as it
	 * 
	 * Assumption 1: Task is in its appropriate file list. There should not
	 * be any exact duplicates of the task in different lists.
	 * 
	 * Assumption 2: If two or more tasks have the same ID, they belong to the
	 * same recur chain. This method will only check for other tasks with the
	 * same ID if the deleted task is recurring
	 */
	public void delete(Task task) throws IOException {
		storage_logger.log(Level.FINE, "Delete operation");
		checkForOverdueTasks();
		
		assert !task.hasNoId();
		
		LinkedList<Task> recur_chain = searchTaskByID(task.getId());
		for (Task other_task : recur_chain) {
			delete(other_task, retrieveTaskList(other_task));
		}
		storage_logger.log(Level.FINE, "Removed " + recur_chain.size() + " tasks");
		recur_chain.clear();
		save();
	}

	private void delete(Task task, PriorityQueue<Task> list) {
		list.remove(task);
	}

	//Retrieval/search methods*************************************************************
	
	//Internal search methods. To be used by Storage only
	
	/*
	 * Searches for all tasks with the same ID.
	 * 
	 * Assumption: Does not search within completed task list. No reason to look for completed tasks
	 */
	private LinkedList<Task> searchTaskByID(int id){
		assert id >= 0;
		storage_logger.log(Level.FINE, "Retrieving tasks with id " + id);
		return id_table.get(id);
	}
		
	public Task getParentTask(Task task) {
		if (task == null) {
			return null;
		}
		assert !task.hasNoId();
		return searchTaskByID(task.getId()).get(0);
	}
	
	//External search methods. Can be called by other classes and tests
	
	public ArrayList<Task> getTasksList() {
		return translateQueueToList(list_task);
	}

	public ArrayList<Task> getFloatingTasksList() {
		return translateQueueToList(list_floating);
	}

	public ArrayList<Task> getCompletedTasksList() {
		return translateQueueToList(list_completed);
	}

	public ArrayList<Task> getOverdueTasksList() {
		return translateQueueToList(list_overdue);
	}
	
	private ArrayList<Task> translateQueueToList(PriorityQueue<Task> pq) {
		ArrayList<Task> list = new ArrayList<Task>();
		Iterator<Task> iter = pq.iterator();
		while (iter.hasNext()) {
			list.add(iter.next());
		}
		return list;
	}
	
	/*
	 * Main search method. Searches for all tasks with the specified parameters: keywords, tags,
	 * within a start and end date.
	 * 
	 * This method accepts null parameters.
	 * 
	 * Assumption: Does not search within completed task list. No reason to look for completed tasks
	 */
	public ArrayList<Task> search(ArrayList<String> keywords, ArrayList<String> tags, Calendar start_date, Calendar end_date) 
			throws IOException {
		storage_logger.log(Level.FINE, "Search operation");
		checkForOverdueTasks();
		if (end_date!=null && start_date != null) {					//make sure end date is later than start date
			if (end_date.before(start_date)) {
				Calendar temp = start_date;
				start_date = end_date;
				end_date = temp;
			}
		}
		ArrayList<Task> search_results = new ArrayList<Task>();
		searchList(search_results, list_overdue, keywords, tags, start_date, end_date);
		searchList(search_results, list_floating, keywords, tags, start_date, end_date);
		searchList(search_results, list_task, keywords, tags, start_date, end_date);
		
		Collections.sort(search_results, new TaskComparator());
		return search_results;
	}
	
	/*
	 * Searches within a specified list and adds it to an input result list.
	 */
	private void searchList(ArrayList<Task> search_result, PriorityQueue<Task> list,
			ArrayList<String> keywords, ArrayList<String> tags, Calendar start_date, Calendar end_date) {
		
		for (Task task : list) {
			if (task.withinDateRange(start_date, end_date)) {
				if ( task.containsKeywords(keywords) && task.containsTags(tags) ) {
					search_result.add(task);
				}
			}
		}
	}
	
	//Clear methods**************************************************************
	
	public void clearAll() throws IOException {
		storage_logger.log(Level.WARNING, "Clearing everything in the storage");
		clear(list_task);
		clear(list_floating);
		clear(list_overdue);
		clear(list_completed);
		buildIDTable();				//should result in empty table and id_counter == 0
		assert id_counter == 0;
		save();
	}
	
	private void clear(PriorityQueue<Task> tasklist) {
		tasklist.clear();
	}
	
	//Save methods***************************************************************
	
	private void save() throws IOException {
		taskFileReader.writeFile(list_task);
		taskFileReader.writeFile(list_floating);
		taskFileReader.writeFile(list_overdue);
		taskFileReader.writeFile(list_completed);
	}
	
	//Miscellaneous methods******************************************************
	
	
	/*
	 * Initialises the task lists by reading from the text files.
	 */
	private void initFiles() throws IOException {
		storage_logger.log(Level.FINE, "Initialising tasklists");
		list_task = new PriorityQueue<Task>(new TaskComparator());
		list_floating = new PriorityQueue<Task>(new TaskComparator());
		list_overdue = new PriorityQueue<Task>(new TaskComparator());
		list_completed = new PriorityQueue<Task>(new TaskComparator());
		taskFileReader.readFile(list_task);
		taskFileReader.readFile(list_floating);
		taskFileReader.readFile(list_completed);
		taskFileReader.readFile(list_overdue);
	}

	/*
	 * Returns the appropriate list for an input task.
	 * This method is primarily used in insert() and delete()
	 */
	private PriorityQueue<Task> retrieveTaskList(Task task) {
		if (task.isFloating()) {
			return list_floating;
		}
		else if (task.isOverdue()) {
			return list_overdue;
		}
		else if (task.isCompleted()) {
			return list_completed;
		}
		return list_task;
	}
	
	/*
	 * Checks for overdue tasks as of time when this method was called, removes them from
	 * the normal task list and inserts them in the overdue task.
	 * 
	 * Assumption 1: There should be no reason to shift overdue tasks back to normal tasks (time is always increasing)
	 * Assumption 2: No reason to check completed tasks
	 * Assumption 3: This is O(|tasklist.size|) timing, but in practice likely to be a small percentage
	 * because user should not have so many overdue tasks, unless he/she didn't use the program for a long time
	 */
	private void checkForOverdueTasks() throws IOException {
		ArrayList<Task> now_overdue_tasks = new ArrayList<Task>();
		while (!list_task.isEmpty() && list_task.peek().isOverdue()) {			//assumes priority queue is always sorted correctly
			now_overdue_tasks.add(list_task.poll());
		}
		list_overdue.addAll(now_overdue_tasks);
		save();
	}
	
	/*
	 * Looks for recurring tasks. If they have no specified recurring limit, update the
	 * default limit as of when this method was called and generate new instances to that
	 * limit.
	 * 
	 * Note: Expensive operation that is of dubious value
	 */
	private void updateRecurringTasks() {
		for (int i = 0; i < id_counter; i++) {
			LinkedList<Task> searchlist = searchTaskByID(i);
			if (!searchlist.isEmpty()) {
				Task lasttask = searchlist.get(searchlist.size()-1);
				if (lasttask.isRecur() && lasttask.getRecurLimit()==null) {
					generateRecurringTasks(lasttask);
				}
			}
		}
	}
	
	/*
	 * Builds the ID table to link families of tasks together and identify them quickly.
	 * Does not include completed tasks.
	 */
	private void buildIDTable() {
		storage_logger.log(Level.FINE, "Building ID Table");
		id_table = new ArrayList<LinkedList<Task>>();
		id_counter = getLatestID();
		for (int i = 0; i <= id_counter; i++) {
			id_table.add(new LinkedList<Task>());
		}
		for (Task task : list_overdue) {
			id_table.get(task.getId()).add(task);
		}
		for (Task task : list_floating) {
			id_table.get(task.getId()).add(task);
		}
		for (Task task : list_task) {
			id_table.get(task.getId()).add(task);
		}
	}

	/*
	 * Updates the ids of the existing tasks in the Storage. Updates id_count as a result, which
	 * should be equal to the number of used ids in Storage.
	 * This is to prevent the ids from growing too much.
	 * 
	 * The outcome of this method should be all ids are compacted, and there are no "holes" within the
	 * occupied ids.
	 * 
	 * Assumption: All ids >= 0. Negative ids are invalid and should not exist.
	 * 
	 * Note: Expensive operation
	 */
	private void compactIndex() {
		storage_logger.log(Level.FINE, "Compacting indexes");
		int holes = 0;
		for (int i = 1; i < id_table.size(); i++) {
			LinkedList<Task> task_family = searchTaskByID(i);
			if (task_family.isEmpty()) {
				holes++;
			}
			else {
				for (Task task : task_family) {
					task.setId(task.getId() - holes);
				}
			}
		}
		for (int i = 1; i < id_table.size(); i++) {
			if (id_table.get(i).isEmpty()) {
				id_table.remove(i);
			}
		}
		id_counter = getLatestID();
		storage_logger.log(Level.FINE, "id_counter = " + id_counter + ", id_table.size() = "
												+ id_table.size());
	}
	
	private int getLatestID() {
		int latest_id = getLatestID(list_task);
		int latest_id_floating = getLatestID(list_floating);
		int latest_id_overdue = getLatestID(list_overdue);
		return Math.max(latest_id, Math.max(latest_id_overdue, latest_id_floating));
	}
	
	private int getLatestID(PriorityQueue<Task> list) {
		int latest_id = 0;
		for (Task task : list) {
			if (latest_id < task.getId()) {
				latest_id = task.getId();
			}
		}
		return latest_id;
	}
	
	//Fix methods***************************************************************************
	
	/*
	 * Through the course of developing this software, there have been often bugs where the
	 * dates on a task suddenly disappeared and appear in wrong folders. Until all bugs are
	 * fixed, providing methods to attempt a fix.
	 * 
	 * Tasks with no ids are always destroyed as they cannot fit in the ID table.
	 * Tasks in the wrong lists are resorted
	 */
	public void maintainListIntegrity() throws IOException {
		storage_logger.log(Level.FINE, "Checking list integrity");
		LinkedList<Task> no_id_tasks = new LinkedList<Task>();
		LinkedList<Task> wrong_tasks = new LinkedList<Task>();
		
		for (Task task : list_task) {
			if (task.hasNoId()) {
				no_id_tasks.add(task);
			}
			else if (task.isCompleted() || task.isFloating() || task.isOverdue()) {
				wrong_tasks.add(task);
			}
		}
		
		for (Task task : list_floating) {
			if (task.hasNoId()) {
				no_id_tasks.add(task);
			}
			else if (!task.isFloating()) {
				wrong_tasks.add(task);
			}
		}
		
		for (Task task : list_overdue) {
			if (!task.isOverdue()) {
				wrong_tasks.add(task);
			}
		}
		
		no_id_tasks.clear();
		for (Task task : list_completed) {
			if (!task.isCompleted()) {
				wrong_tasks.add(task);
			}
		}
		
		if (no_id_tasks.size() > 0) {
			storage_logger.log(Level.WARNING, "There are tasks with no IDs");
		}
		
		if (wrong_tasks.size() > 0) {
			storage_logger.log(Level.WARNING, "There are tasks in the wrong files");
		}
		
		list_floating.removeAll(no_id_tasks);
		list_overdue.removeAll(no_id_tasks);
		list_task.removeAll(no_id_tasks);
		list_completed.removeAll(no_id_tasks);
		
		list_floating.removeAll(wrong_tasks);
		list_overdue.removeAll(wrong_tasks);
		list_task.removeAll(wrong_tasks);
		list_completed.removeAll(wrong_tasks);
		
		for (Task task : wrong_tasks) {
			retrieveTaskList(task).add(task);
		}
		buildIDTable();
		compactIndex();
		save();
	}
	
	// End of segment: ./src\speed\storage\Storage.java





	/**
	 * origin: ./src\speed\storage\StorageJUnitTest.java
	 */

package speed.storage;

import org.junit.Test;

import speed.task.Task;
import speed.task.TaskComparator;

import java.io.File;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collections;

import static org.junit.Assert.assertEquals;

public class StorageJUnitTest {

	@Test
	public void test() {
		try {

			// Task tests**********************************************************
			
			/*
			 * Most of these are meant to test the date methods. All other Task
			 * fields are independent, therefore only checked once or twice to
			 * reduce the number of combinations required.
			 * 
			 * In addition, these tasks will be reused for later tests
			 * 
			 * WARNING: Due to time sensitivity of overdue tasks, it is assumed
			 * these tests are not used by 26 Nov 2015. Also all recurring tasks will
			 * only contribute to the normal tasks file (no overdue). However
			 * since retrieveTaskFile() is independent of recurrence generation,
			 * it is assumed that the result is the same for overdue tasks.
			 * 
			 * NOTE: The software on a whole recognises tags by special signs. In this
			 * unit test, however, arbitrary tags are added without needing those
			 * signs
			*/
			
			System.out.println("Task tests");
			
			// Task 1: Normal task
			// Also checks methods related to taskName, keywords, tags are working
			// Assumes 1 date
			Task task1 = new Task();
			task1.setTaskName("Submit Developer Guide");
			Calendar task1_date = Calendar.getInstance();
			task1_date.set(2014, Calendar.NOVEMBER, 26, 13, 00, 00);
			task1.setDates(task1_date, task1_date, -1, -1, null);			//start date same as end date
			task1.addTag("school");
			task1.addTag("CS2101");
			task1.addTag("CS2103T");

			Calendar task1_test_start_date = Calendar.getInstance();
			task1_test_start_date.set(2014, Calendar.NOVEMBER, 26, 12, 59, 59);
			Calendar task1_test_end_date = Calendar.getInstance();
			task1_test_end_date.set(2014, Calendar.NOVEMBER, 26, 13, 00, 01);

			//Task name check
			test(task1.getTaskName(), "Submit Developer Guide");
			//Tags check
			test(task1.getTags().size(), 3);
			test(task1.getTags().get(0), "CS2101");
			test(task1.getTags().get(1), "CS2103T");
			test(task1.getTags().get(2), "school");
			test(task1.getTagsAsString(), "CS2101, CS2103T, school");
			//dates check
			test(task1.getStartDate(), task1_date);
			test(task1.getEndDate(), task1_date);
			test(task1.getDate(), task1_date);
			test(task1.getDateAsString(), "Wed 26-Nov-14 13:00 PM");
			test(task1.getDateCompleted(), null);
			//boolean checks
			test(task1.isFloating(), false);
			test(task1.isOverdue(), false);
			test(task1.isCompleted(), false);
			test(task1.isRecur(), false);
			test(task1.withinDateRange(task1_test_start_date,
					task1_test_end_date), true);
			task1_test_start_date.set(2014, Calendar.NOVEMBER, 26, 13, 00, 00);
			test(task1.withinDateRange(task1_test_start_date,					//Observation: This returns false at times. Waiting a while and testing it again returns true. May be a time sensitive issue
					task1_test_end_date), true);
			test(task1.withinDateRange(null, null), true);						//Empty search date

			// Task 2: Task with interval
			Task task2 = new Task();
			task2.setTaskName("MA3110 finals");
			Calendar task2_start_date = Calendar.getInstance();
			task2_start_date.set(2014, Calendar.NOVEMBER, 27, 13, 00, 00);
			Calendar task2_end_date = Calendar.getInstance();
			task2_end_date.set(2014, Calendar.NOVEMBER, 27, 15, 00, 00);
			task2.setDates(task2_end_date, task2_start_date);					//insert in wrong order. Task should automatically right it
			task2.addTag("school");
			task2.addTag("MA3110");
			task2.addTag("exams");

			Calendar task2_test_start_date = Calendar.getInstance();
			task2_test_start_date.set(2014, Calendar.NOVEMBER, 24, 12, 59, 59);
			Calendar task2_test_end_date = Calendar.getInstance();
			task2_test_end_date.set(2014, Calendar.NOVEMBER, 28, 13, 00, 01);
			
			test(task2.getStartDate(), task2_start_date);
			test(task2.getEndDate(), task2_end_date);						//task should detect wrong order and fix it
			
			test(task2.withinDateRange(task2_test_start_date,
					task2_test_end_date), true);
			task2_test_start_date.set(2014, Calendar.NOVEMBER, 27, 13, 30, 00);
			test(task2.withinDateRange(task2_test_start_date,
					task2_test_end_date), true);
			task2_test_end_date.set(2014, Calendar.NOVEMBER, 27, 14, 30, 00);
			test(task2.withinDateRange(task2_test_start_date,
					task2_test_end_date), true);

			// Task 3: Overdue Task
			// Note: Overdue check generates an instance of the current date. Test
			// may therefore be sensitive to when it was conducted
			Task task3 = new Task();
			task3.setTaskName("100 pushups");
			Calendar task3_date = Calendar.getInstance();
			task3_date.set(2014, Calendar.OCTOBER, 8, 10, 00, 00);
			task3.setDate(task3_date);
			task3.addTag("exercise");

			test(task3.isOverdue(), true);

			// Task 4: Floating Task
			Task task4 = new Task();
			task4.setTaskName("Bake chocolate cake");
			task4.addTag("baking");
			
			//this is gibberish input and should not affect further tests, until a date is set
			task4.setRecur(Calendar.YEAR, 3);
			Calendar task4_recur_limit = Calendar.getInstance();
			task4_recur_limit.set(2016, Calendar.JANUARY, 1, 0, 0, 0);
			task4.setRecurLimit(task4_recur_limit);

			test(task4.getStartDate(), null);
			test(task4.getEndDate(), null);
			test(task4.isRecur(), false);
			test(task4.isFloating(), true);
			
			/*
			 * All recurring is only activated during Storage insertion
			 * Due to sensitivity of Calendar fields, tests will check all
			 * fields that can be recurred (YEAR, MONTH, WEEK, DAY)
			 */

			// Task 5: Recurring Task (YEAR)
			// no recur limit: Storage uses its own (TIME SENSITIVE)
			Task task5 = new Task();
			task5.setTaskName("Casey's birthday");
			task5.addTag("Casey");
			task5.addTag("birthdays");
			Calendar task5_start_date = Calendar.getInstance();
			task5_start_date.set(2014, Calendar.SEPTEMBER, 29, 00, 00, 00);
			Calendar task5_end_date = Calendar.getInstance();
			task5_end_date.set(2014, Calendar.SEPTEMBER, 29, 23, 59, 59);
			task5.setDates(task5_start_date, task5_end_date, Calendar.YEAR, 1, null);
			task5.setCompleted();
			test(task5.isRecur(), true);
			test(task5.isCompleted(), true);

			// Task 6: Recurring Task (MONTH)
			//contains a limit
			Task task6 = new Task();
			task6.setTaskName("Get pay");
			Calendar task6_date = Calendar.getInstance();
			task6_date.set(2016, Calendar.JANUARY, 1, 00, 00, 00);
			Calendar task6_limit = Calendar.getInstance();
			task6_limit.set(2017, Calendar.DECEMBER, 30, 00, 00, 00);
			task6.setDates(task6_date, task6_date, Calendar.MONTH, 1, task6_limit);

			// Task 7: Recurring Task (WEEK)

			Task task7 = new Task();
			task7.setTaskName("Go jogging");
			task7.addTag("exercise");
			Calendar task7_date = Calendar.getInstance();
			task7_date.set(2015, Calendar.OCTOBER, 5, 8, 00, 00);
			Calendar task7_limit = Calendar.getInstance();
			task7_limit.set(2016, Calendar.JANUARY, 30, 00, 00, 00);
			task7.setDate(task7_date);
			task7.setRecur(Calendar.WEEK_OF_YEAR, 1);
			task7.setRecurLimit(task7_limit);

			// Task 8: Recurring Task (DAY)
			Task task8 = new Task();
			task8.setTaskName("Go to sleep by 11");
			Calendar task8_date = Calendar.getInstance();
			task8_date.set(2015, Calendar.NOVEMBER, 1, 23, 00, 00);
			Calendar task8_limit = Calendar.getInstance();
			task8_limit.set(2015, Calendar.DECEMBER, 1, 23, 00, 01);
			task8.setDate(task8_date);
			task8.setRecur(Calendar.DAY_OF_YEAR, 1);
			task8.setRecurLimit(task8_limit);

			// completed tasks
			
			task3.setDateCompleted(Calendar.getInstance());
			test(task3.isCompleted(), true);
			test(task3.isOverdue(), false);
			test(task3.isFloating(), false);
			task3.setIncomplete();
			test(task3.isCompleted(), false);
			test(task3.isOverdue(), true);
			
			task4.setDateCompleted(Calendar.getInstance());
			test(task4.isFloating(), false);
			test(task4.isCompleted(), true);
			task4.setDateCompleted(null);
			test(task4.isFloating(), true);
			test(task4.isCompleted(), false);
			
			
			// TaskComparator test
			
			/*
			 * NOTE: In the Storage and the overall software, floating, overdue,
			 * completed and normal tasks are supposed to be separate from each other.
			 */
			
			ArrayList<Task> sorted_list = new ArrayList<Task>();
			sorted_list.add(task1);
			sorted_list.add(task2);
			sorted_list.add(task3);
			sorted_list.add(task4);
			sorted_list.add(task5);
			sorted_list.add(task6);
			sorted_list.add(task7);
			sorted_list.add(task8);
			
			Collections.sort(sorted_list, new TaskComparator());
			
			test(sorted_list.get(0).getTaskName(), task3.getTaskName());
			test(sorted_list.get(1).getTaskName(), task4.getTaskName());
			test(sorted_list.get(2).getTaskName(), task1.getTaskName());
			test(sorted_list.get(3).getTaskName(), task2.getTaskName());
			test(sorted_list.get(4).getTaskName(), task7.getTaskName());
			test(sorted_list.get(5).getTaskName(), task8.getTaskName());
			test(sorted_list.get(6).getTaskName(), task6.getTaskName());
			test(sorted_list.get(7).getTaskName(), task5.getTaskName());

			// Storage
			// tests*********************************************************************
			
			String storagetesttask = "storagetesttask.txt";
			String storagetestfloat = "storagetestfloat.txt";
			String storagetestoverdue = "storagetestoverdue.txt";
			String storagetestcomplete = "storagetestcomplete.txt";

			Storage storage = new Storage(storagetesttask,storagetestfloat,storagetestoverdue,storagetestcomplete);
			storage.clearAll();

			// Insertion tests************************************
			// Implicitly tests retrieveTaskFile()
			System.out.println("Insertion tests");
			
			storage.insert(task1);
			test(storage.getTasksList().size(), 1);
			storage.insert(task2);

			// insert overdue task
			storage.insert(task3);
			test(storage.getOverdueTasksList().size(), 1);

			// insert floating task
			storage.insert(task4);
			test(storage.getFloatingTasksList().size(), 1);

			// insert recurring tasks. Storage should automatically generate
			// all recurring instances according to their or the default limit
			storage.insert(task5);
			test(storage.getCompletedTasksList().size(), 1);
			test(storage.getCompletedTasksList().get(0).getTaskName(), "Casey's birthday");
			test(storage.getCompletedTasksList().get(0).getDateAsString(), "Mon 29-Sep-14 0:00 AM -\nMon 29-Sep-14 23:59 PM");
			test(storage.getTasksList().size(), 5);
			test(storage.getTasksList().get(2).getTaskName(), "Casey's birthday");
			test(storage.getTasksList().get(2).getDateAsString(), "Tue 29-Sep-15 0:00 AM -\nTue 29-Sep-15 23:59 PM");
			test(storage.getTasksList().get(2).getId(), storage.getCompletedTasksList().get(0).getId());
			test(storage.getTasksList().get(3).getTaskName(), "Casey's birthday");
			test(storage.getTasksList().get(3).getDateAsString(), "Thu 29-Sep-16 0:00 AM -\nThu 29-Sep-16 23:59 PM");
			test(storage.getTasksList().get(4).getTaskName(), "Casey's birthday");
			test(storage.getTasksList().get(4).getDateAsString(), "Fri 29-Sep-17 0:00 AM -\nFri 29-Sep-17 23:59 PM");
			storage.insert(task6);
			test(storage.getTasksList().size(), 29);
			storage.insert(task7);
			test(storage.getTasksList().size(), 46);
			storage.insert(task8);
			test(storage.getTasksList().size(), 77);

			// Deletion tests**********************************
			System.out.println("Deletion tests");

			storage.delete(task3);
			test(storage.getOverdueTasksList().size(), 0);

			// deleting from empty list/non-existent task
			storage.delete(task3);
			test(storage.getOverdueTasksList().size(), 0);

			// testing reinsertion after modification
			// ***This is how the controller should modify task: delete, modify, then reinsert
			
			task3.setDates(null, null);
			storage.insert(task3);
			test(storage.getFloatingTasksList().size(), 2);
			storage.delete(task3);
			test(storage.getFloatingTasksList().size(), 1);
			
			task3.setDateCompleted(Calendar.getInstance());
			storage.insert(task3);
			test(storage.getCompletedTasksList().size(), 2);
			storage.delete(task3);
			task3.setDateCompleted(null);
			task3.setTaskName("100 situps");
			storage.insert(task3);
			test(storage.getFloatingTasksList().size(), 2);
			test(storage.getFloatingTasksList().get(0).getTaskName(), "100 situps");
			test(storage.getFloatingTasksList().get(1).getTaskName(), "Bake chocolate cake");
			storage.delete(task3);
			task3.setTaskName("100 pushups");
			task3.setDate(task3_date);
			storage.insert(task3);
			test(task3.isOverdue(), true);
			
			//delete recurring task
			storage.delete(task8);
			test(storage.getTasksList().size(), 46);
			storage.insert(task8);
			test(storage.getTasksList().size(), 77);

			// Search tests********************************
			
			// Note: search does not check completed tasks
			
			System.out.println("Search tests");
			
			// search with no date

			ArrayList<String> search1_keywords = new ArrayList<String>();
			search1_keywords.add("casey");										//test case sensitivity
			ArrayList<Task> search1 = storage.search(search1_keywords, null,
					null, null);
			test(search1.size(), 3);
			test(search1.get(0).getTaskName(), "Casey's birthday");
			test(search1.get(1).getTaskName(), "Casey's birthday");
			test(search1.get(2).getTaskName(), "Casey's birthday");

			// search no date, multiple keywords, from multiple lists
			// checks the order of the tasks (overdue, floating, normal)
			ArrayList<String> search2_keywords = new ArrayList<String>();
			search2_keywords.add("1");
			search2_keywords.add("0");
			ArrayList<Task> search2 = storage.search(search2_keywords, null,
					null, null);
			test(search2.size(), 2);
			test(search2.get(0).getTaskName(), "100 pushups");
			test(search2.get(1).getTaskName(), "MA3110 finals");

			// search tags in combination with keywords
			ArrayList<String> search2_tags = new ArrayList<String>();
			search2_tags.add("school");
			search2 = storage
					.search(search2_keywords, search2_tags, null, null);
			test(search2.size(), 1);
			test(search2.get(0).getTaskName(), "MA3110 finals");

			// search date
			Calendar search3_start = Calendar.getInstance();
			search3_start.set(2014, Calendar.OCTOBER, 1, 00, 00, 00);
			Calendar search3_end = Calendar.getInstance();
			search3_end.set(2015, Calendar.OCTOBER, 1, 00, 00, 00);
			ArrayList<Task> search3 = storage.search(null, null, search3_start,
					search3_end);
			test(search3.size(), 5);
			test(search3.get(0).getTaskName(), "100 pushups");				//can find overdue through date
			test(search3.get(1).getTaskName(), "Bake chocolate cake");		//can find floating through date
			test(search3.get(4).getTaskName(), "Casey's birthday");
			test(search3.get(4).getDateAsString(), "Tue 29-Sep-15 0:00 AM -\nTue 29-Sep-15 23:59 PM");
			
			

			// search parameters that should not find any task
			Calendar search4_start = Calendar.getInstance();
			search4_start.set(2014, Calendar.DECEMBER, 1, 00, 00, 00);
			Calendar search4_end = Calendar.getInstance();
			search4_end.set(2015, Calendar.JANUARY, 1, 00, 00, 00);
			ArrayList<String> search4_keywords = new ArrayList<String>();
			search4_keywords.add("finals");
			ArrayList<String> search4_tags = new ArrayList<String>();
			search4_tags.add("CS2103T");
			ArrayList<Task> search4 = storage.search(search4_keywords,
					search4_tags, search4_start, search4_end);
			test(search4.size(), 0);

			// delete, then search
			// then insert, search
			ArrayList<String> search5_keywords = new ArrayList<String>();
			search5_keywords.add("birthday");
			storage.delete(task5);
			ArrayList<Task> search5 = storage.search(search5_keywords, null,
					null, null);
			test(search5.size(), 0);
			storage.insert(task5);
			search5 = storage.search(search5_keywords, null, null, null);
			test(search5.size(), 3);

			//cleanup
			storage.clearAll();
			File del_file = new File(storagetesttask);
			del_file.delete();
			del_file = new File(storagetestfloat);
			del_file.delete();
			del_file = new File(storagetestoverdue);
			del_file.delete();
			del_file = new File(storagetestcomplete);
			del_file.delete();
			System.out.println("All tests successful");
		}
		
		catch (Exception e) {
			e.printStackTrace();
		}
	}

	public void test(String a, String b) {
		assertEquals(b, a);
	}

	public void test(boolean a, boolean b) {
		assertEquals(b, a);
	}

	private void test(int a, int b) {
		assertEquals(b, a);
	}
	
	private void test(Calendar a, Calendar b) {
		assertEquals(b, a);
	}
}

	// End of segment: ./src\speed\storage\StorageJUnitTest.java





	/**
	 * origin: ./src\speed\task\Task.java
	 */

package speed.task;
import java.util.ArrayList;
import java.util.Calendar;

import java.text.SimpleDateFormat;

/*
 * This class is used to represent a user task, which can be modified and stored by other classes. The
 * Task class contains several fields meant to cater to as wide a range of applications as possible. The
 * primary fields are taskName (description of task), the date fields and tags.
 * 
 * Tasks are categorised into four types: Floating (no dates), Overdue (past the current time), Completed
 * (marked as completed), and Normal (otherwise). The four are mutually exclusive and spans all possible
 * tasks this software intends to cover. In addition, this class supports recurring tasks. This is represented
 * by the recurX fields, which are to be used by other classes to create recurring copies.
 */

public class Task {

	private static final SimpleDateFormat sdf = new SimpleDateFormat("EE d-MMM-yy H:mm a");
	private static final int RECUR_PATTERN_INVALID = -1;
	private static final int RECUR_PERIOD_VALID_MINIMUM = 1;
	
	private Integer id;
	private String taskName;
	private String displayId;
	private Calendar startDate;
	private Calendar endDate;
	private Calendar dateCompleted;
	private Integer recurPattern;
	private Integer recurPeriod;
	private Calendar recurLimit;								//NOT USED as of V0.4. Always null
	private ArrayList<String> tags;

	//Constructors******************************************************************************
	
	/*
	 * No input constructor. This should be the only used constructor. Fields are then to be added
	 * by provided setter methods
	 */
	public Task() {
		this(null, "", "", null, null, null, RECUR_PATTERN_INVALID, RECUR_PERIOD_VALID_MINIMUM - 1,
				null, new ArrayList<String>());
	}

	//private constructor
	private Task(Integer taskId, String displayId, String taskName,
			Calendar taskStartDate, Calendar taskEndDate, Calendar taskDateCompleted,
			Integer recur, Integer recurPeriod, Calendar recurLimit, ArrayList<String> taskTag) {
		this.id = taskId;
		this.displayId = displayId;
		this.taskName = taskName;
		this.startDate = taskStartDate;
		this.endDate = taskEndDate;
		this.dateCompleted = taskDateCompleted;
		this.recurPattern = recur;
		this.recurPeriod = recurPeriod;
		this.recurLimit = recurLimit;
		this.tags = taskTag;
	}

	// Task ID*************************************************************************
	
	/*
	 * This field is used for identifying tasks.
	 * 
	 * Note: This field is only used by the Storage, and has no consequences in the UI and Controller.
	 * Tasks with the same id are grouped as the same "family" of tasks. This has consequences in the
	 * Storage (recurring tasks).
	 */
	
	public void setId(int id) {
		this.id = id;
	}

	public int getId() {
		return this.id;
	}

	public boolean hasNoId() {
		return id == null || id < 0;
	}

	// Task DisplayID******************************************************************

	/*
	 * This field is a separate id, for identifying tasks.
	 * 
	 * Note: This field is only used by the UI and Controller, and has no consequence in
	 * the Storage. It is meant for display purposes. Multiple tasks can have the same
	 * displayId.
	 */
	
	public void setDisplayId(String id) {
		this.displayId = id;
	}

	public String getDisplayId() {
		return this.displayId;
	}

	// Task Name***********************************************************************
	
	/*
	 * This field contains the description of the task.
	 */
	
	public void setTaskName(String taskname) {
		this.taskName = taskname;
	}

	public String getTaskName() {
		return this.taskName;
	}
	
	private boolean containsKeyword(String keyword) {
		return taskName.toLowerCase().contains(keyword.toLowerCase());
	}

	public boolean containsKeywords(ArrayList<String> keywords) {
		if (keywords == null) {
			return true;
		}
		for (String keyword : keywords) {
			if (!containsKeyword(keyword)) {
				return false;
			}
		}
		return true;
	}

	// Task Dates**********************************************************************
	
	/*
	 * Sets the field start_date, end_date, recur_pattern, recur_period and recur_limit.
	 * 
	 * start_date: starting date and time of the task.
	 * end_date: ending date and time of the task.
	 * recur_pattern: The type of recurring pattern, based on Calendar fields. Includes Calendar.YEAR,
	 * 		Calendar.MONTH, Calendar.WEEK_OF_YEAR, Calendar.DAY_OF_YEAR etc.
	 * recur_period: The period at which this task recurs. For example, every 2 years => pattern = YEAR, period = 2
	 * recur_limit: A date, which the recurring task ends by then. NOT USED as of V0.4.
	 * 
	 * ASSUMPTION 1: start_date and end_date are always either both null or both existing. No support
	 * for tasks with null start_date and non-null end_date, and vice versa.
	 * 
	 * ASSUMPTION 2: For tasks with a single date, the start_date and end_date are the same.
	 * 
	 * ASSUMPTION 3: recur_pattern is either INVALID or an appropriate Calendar field.
	 * 
	 * ASSUMPTION 4: recur_period is not negative.
	 */
	
	public void setDates(Calendar startdate, Calendar enddate, int recurpattern, int recurperiod, Calendar recurlimit) {
		
		//perform an internal check to see if end date is before start date. If it is, do a swap.
		if (enddate!= null && startdate!= null && enddate.before(startdate)) {
			Calendar temp = enddate;
			enddate = startdate;
			startdate = temp;
		}
		
		//perform a check and see if startdate is null when enddate is not. If so, clone startdate
		if (enddate!=null && startdate == null) {
			startdate = (Calendar) enddate.clone();
		}
		
		this.startDate = startdate;
		this.endDate = enddate;
		this.recurPattern = recurpattern;
		this.recurPeriod = recurperiod;
		this.recurLimit = recurlimit;
	}

	/*
	 * Sets start_date and end_date. Recurring fields are immediately set to invalid,
	 * non-recurring values. This is for nonrecurring tasks.
	 * 
	 * NOT USED as of V0.4.
	 */
	public void setDates(Calendar startdate, Calendar enddate) {
		setDates(startdate, enddate, RECUR_PATTERN_INVALID, RECUR_PERIOD_VALID_MINIMUM - 1, null);
	}

	/*
	 * Sets a single date. end_date is set to be the same as the start_date. This is for
	 * tasks with only a single date.
	 * 
	 * NOT USED as of V0.4.
	 */
	public void setDate(Calendar date, int recur_pattern, int recur_period, Calendar recur_limit) {
		setDates(date, (Calendar) date.clone(), recur_pattern, recur_period, recur_limit);
	}

	/*
	 * Sets a single date without recurring fields.
	 * 
	 * NOT USED as of V0.4.
	 */
	public void setDate(Calendar date) {
		setDate(date, RECUR_PATTERN_INVALID, RECUR_PERIOD_VALID_MINIMUM, null);
	}
	
	/*
	 * Setters for individual fields.
	 * 
	 * WARNING: Can lead to potential abuse. Use with caution.
	 */
	private void setStartDate(Calendar startdate) {
		this.startDate = startdate;
	}

	private void setEndDate(Calendar enddate) {
		this.endDate = enddate;
	}
	
	public void setRecur(Integer pattern, Integer period) {
		this.recurPattern = pattern;
		this.recurPeriod = period;
	}

	public void setRecurLimit(Calendar limit) {
		this.recurLimit = limit;
	}

	/*
	 * Getter methods
	 */
	
	public Calendar getStartDate() {
		return this.startDate;
	}

	public Calendar getEndDate() {
		return this.endDate;
	}
	
	/*
	 * Meant for dates with a single date (start_date same as end_date)
	 * NOT USED as of V0.4.
	 */
	public Calendar getDate() {
		return this.endDate;
	}
	
	public Integer getRecurPattern() {
		return this.recurPattern;
	}
	
	public Integer getRecurPeriod() {
		return this.recurPeriod;
	}

	public Calendar getRecurLimit() {
		return this.recurLimit;
	}
	
	/*
	 * Checks whether this is a recurring task. Recurring tasks are classified as:
	 * Appropriate pattern: (Default invalid: -1)
	 * Appropriate period (>=1)
	 * Non-null start and end dates (not floating)
	 */
	public boolean isRecur() {
		return this.recurPattern != RECUR_PATTERN_INVALID &&
				this.recurPeriod >= RECUR_PERIOD_VALID_MINIMUM &&
				this.startDate != null && this.endDate != null;
	}

	/*
	 * Gets the dates as String format.
	 * 
	 * Note: Primarily for the UI, so that it does not need to know how to read Calendar.
	 */

	public String getStartDateAsString() {
		if (this.startDate == null) {
			return "";
		}
		return sdf.format(startDate.getTime());
	}

	public String getEndDateAsString() {
		if (this.endDate == null) {
			return "";
		}
		return sdf.format(endDate.getTime());
	}

	public String getDateAsString() {
		if (this.startDate == null && this.endDate == null) {
			return "";
		}
		if (this.startDate == null) {
			return sdf.format(endDate.getTime());
		}
		if (this.endDate == null) {
			return sdf.format(startDate.getTime());
		}
		if (this.startDate.equals(this.endDate)) {
			return sdf.format(endDate.getTime());
		}
		return sdf.format(startDate.getTime()) + " -\n"
				+ sdf.format(endDate.getTime());
	}
	
	public String getRecurAsString() {
		String result = "every ";
		if (recurPeriod > 1) {
			result += recurPeriod + " ";
		}
		switch (this.recurPattern) {
			case Calendar.YEAR:
				result += "year";
				break;
			case Calendar.MONTH:
				result += "month";
				break;
			case Calendar.WEEK_OF_YEAR:
				result += "week";
				break;
			case Calendar.DAY_OF_YEAR:
				result += "day";
				break;
			default:
				return "";
		}
		if (recurPeriod > 1) {
			result += "s";
		}
		return result;
	}

	// Task Completed******************************************************************
	
	/*
	 * The dateCompleted field checks whether this Task is completed. A task is considered
	 * completed if the dateCompleted is equal or after its end_date. If it is a floating
	 * task, a non-null dateCompleted field means it's completed. A null dateCompleted field
	 * immediately means incomplete.
	 */
	
	public void setDateCompleted(Calendar c) {
		this.dateCompleted = c;
	}
	
	/*
	 * Easier method so that external classes need not look for an appropriate date input 
	 */
	public void setCompleted() {
		Calendar dateCompleted = Calendar.getInstance();
		if (this.endDate != null) {
			dateCompleted = (Calendar) this.endDate.clone();
			dateCompleted.add(Calendar.SECOND, 1);
		}
		setDateCompleted(dateCompleted);
	}
	
	public void setIncomplete() {
		setDateCompleted(null);
	}

	public Calendar getDateCompleted() {
		return this.dateCompleted;
	}

	public boolean isCompleted() {
		if (this.dateCompleted == null) {
			return false;
		}
		if (this.endDate == null && this.dateCompleted != null) {		//assumption that start_date.equals == null and start_date <= end_date
			return true;
		}
		return this.dateCompleted.after(this.endDate);					//assumption that start_date.equals(end_date)
	}

	/*
	 * Returns dateCompleted as a String.
	 * 
	 * Note: Meant for UI
	 * 
	 * NOT USED as of V0.4.
	 */
	public String getDateCompletedAsString() {
		return sdf.format(this.dateCompleted.getTime());
	}
	
	// Other checks*******************************************************************************
	
	/*
	 * Floating task check. Floating tasks are considered incomplete tasks with null start and end dates.
	 * 
	 * ASSUMPTION: start_date == null iff end_date == null.
	 */
	public boolean isFloating() {
		return this.startDate == null && this.endDate == null
				&& this.dateCompleted == null;
	}

	/*
	 * Overdue task check. Floating and Completed tasks automatically fail this check: Floating
	 * will never be overdue, and Completed is completed. Generates an instance of the time now
	 * and compares with the end date.
	 */
	public boolean isOverdue() {
		if (isFloating()) {
			return false;
		}

		if (isCompleted()) {
			return false;
		}

		assert endDate != null;
		Calendar now = Calendar.getInstance();
		
		if (this.endDate.before(now)) {
			return true;
		}

		return false;
	}

	/*
	 * Checks whether the task is within two input dates. As long as one of the task dates is within
	 * this interval, this check returns true. Floating and Overdue tasks immediately pass this check.
	 */
	public boolean withinDateRange(Calendar start_date, Calendar end_date) {
		if (isFloating()) {
			return true;
		}
		if (isOverdue()) {
			return true;
		}
		if (start_date == null || start_date.before(this.endDate)
				|| start_date.equals(this.endDate)) {
			if (end_date == null || end_date.after(this.startDate)
					|| end_date.equals(this.startDate)) {
				return true;
			}
		}
		return false;
	}

	// Task Tags**********************************************************************
	public void addTag(String tag) {
		this.tags.add(tag);
		this.tags.sort(null);
	}
	
	public void removeTag(String tag) {
		this.tags.remove(tag);
	}

	public ArrayList<String> getTags() {
		return this.tags;
	}

	private boolean containsTag(String tag) {
		for (String t : this.tags) {
			if (t.toLowerCase().equals(tag.toLowerCase())) {
				return true;
			}
		}
		return false;
	}

	public boolean containsTags(ArrayList<String> tags) {
		if (tags == null) {
			return true;
		}
		for (String tag : tags) {
			if (!containsTag(tag)) {
				return false;
			}
		}
		return true;
	}

	public String getTagsAsString() {
		String tagsUI = "";
		for (int i = 0; i < tags.size(); i++) {
			tagsUI += tags.get(i);
			if (i < tags.size() - 1) {
				tagsUI += ", ";
			}
		}
		return tagsUI;
	}

	// Clone methods***************************************************************

	public Task clone() {
		Task task = new Task();
		task.setId(this.id);
		task.setTaskName(this.taskName);
		if (this.startDate != null) {
			task.setStartDate((Calendar) this.startDate.clone());
		}
		if (this.endDate != null) {
			task.setEndDate((Calendar) this.endDate.clone());
		}
		if (this.dateCompleted != null) {
			task.setDateCompleted((Calendar) this.dateCompleted.clone());
		}
		task.setRecur(this.recurPattern, this.recurPeriod);
		if (this.recurLimit != null) {
			task.setRecurLimit((Calendar) this.recurLimit.clone());
		}
		for (String tag : tags) {
			task.addTag(tag);
		}
		return task;
	}
}


	// End of segment: ./src\speed\task\Task.java





	/**
	 * origin: ./src\speed\task\TaskComparator.java
	 */

package speed.task;

import java.util.Comparator;

 public class TaskComparator implements Comparator<Task> {
	 public int compare(Task a, Task b) {
		if (!a.isCompleted() && b.isCompleted()) {
			return -1;
		}
		if (a.isCompleted() && !b.isCompleted()) {
			return 1;
		}
		if (a.isOverdue() && !b.isOverdue()) {
			return -1;
		}
		if (!a.isOverdue() && b.isOverdue()) {
			return 1;
		}
		if (a.getStartDate() == null && b.getStartDate() == null) {
			return a.getTaskName().compareTo(b.getTaskName());
		}
		if (a.getStartDate() == null && b.getStartDate() != null) {
			return -1;
		}
		if (a.getStartDate() != null && b.getStartDate() == null) {
			return 1;
		}
		if (a.getStartDate().before(b.getStartDate())) {
			return -1;
		}
		if (a.getStartDate().equals(b.getStartDate())) {
			return a.getTaskName().compareTo(b.getTaskName());
		}
		return 1;
	}
}
	// End of segment: ./src\speed\task\TaskComparator.java





